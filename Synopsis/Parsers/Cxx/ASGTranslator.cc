//
// Copyright (C) 2005 Stefan Seefeld
// All rights reserved.
// Licensed to the public under the terms of the GNU LGPL (>= 2),
// see the file COPYING for details.
//

#include "ASGTranslator.hh"
#include <Synopsis/Trace.hh>
#include <Synopsis/PTree/Writer.hh> // for PTree::reify
#include <Synopsis/PTree/Display.hh> // for PTree::display (debugging...)
#include <Synopsis/SymbolTable/Display.hh> // for SymbolTable::display (debugging...)
#include <Support/path.hh>

using Synopsis::Token;
using Synopsis::Trace;
namespace PT = Synopsis::PTree;
namespace ST = Synopsis::SymbolTable;

namespace
{
//. Extract the name of the class as a qualified name.
//. The name is either an identifier, a (qualified) name,
//. or nil, in which case we use the synthetic name generated by
//. the parser.
//. FIXME: Don't use the name for anonymous classes. It is wrong
//.        since multiple generated names will clash across multiple
//.        compilation units.
class ClassNameFinder : PT::Visitor
{
public:
  bpl::list name(PT::ClassSpec *spec)
  {
    if (spec->name()) spec->name()->accept(this);
    else
    {
      PT::Encoding ename = spec->encoded_name();
      size_t length = (ename.front() - 0x80);
      name_ = bpl::list(std::string(ename.begin() + 1, ename.begin() + 1 + length));

    }
    return name_;
  }
  bpl::list name(PT::ElaboratedTypeSpec *spec)
  {
    spec->name()->accept(this);
    return name_;
  }
private:
  virtual void visit(PT::Identifier *id) { name_ = bpl::list(PT::string(id));}
  virtual void visit(PT::Name *node)
  {
    PT::Encoding name = node->encoded_name();
    for (PT::Encoding::name_iterator next = name.begin_name();
	 next != name.end_name();
	 ++next)
      name_.append(name.unmangled());
  }

  bpl::list name_;
};

inline bpl::tuple qname(std::string const &name) { return bpl::tuple(name);}
inline bpl::dict annotations(bpl::object o) { return bpl::extract<bpl::dict>(o.attr("annotations"));}
inline bpl::list comments(bpl::object o) { return bpl::extract<bpl::list>(annotations(o).get("comments"));}
}

ASGTranslator::ASGTranslator(ST::Scope *scope,
			     std::string const &filename,
			     std::string const &base_path, bool primary_file_only,
			     bpl::object ir, bool v, bool d)
  : Walker(scope),
    asg_module_(bpl::import("Synopsis.ASG")),
    sf_module_(bpl::import("Synopsis.SourceFile")),
    files_(bpl::extract<bpl::dict>(ir.attr("files"))()),
    types_(bpl::extract<bpl::dict>(ir.attr("types"))()),
    declarations_(bpl::extract<bpl::list>(ir.attr("declarations"))()),
    raw_filename_(filename),
    base_path_(base_path),
    primary_file_only_(primary_file_only),
    lineno_(0),
    in_class_(false),
    verbose_(v),
    debug_(d) 
{
  Trace trace("ASTTranslator::ASTTranslator", Trace::TRANSLATION);

  // define all the builtin types
  bpl::object define = types_.attr("__setitem__");
  types_[qname("bool")] =  asg_module_.attr("BaseType")("C++", qname("bool"));
  types_[qname("char")] =  asg_module_.attr("BaseType")("C++", qname("char"));
  types_[qname("short")] =  asg_module_.attr("BaseType")("C++", qname("short"));
  types_[qname("int")] =  asg_module_.attr("BaseType")("C++", qname("int"));
  types_[qname("long")] =  asg_module_.attr("BaseType")("C++", qname("long"));
  types_[qname("unsigned")] =  asg_module_.attr("BaseType")("C++", qname("unsigned"));
  types_[qname("unsigned long")] =  asg_module_.attr("BaseType")("C++", qname("unsigned long"));
  types_[qname("float")] =  asg_module_.attr("BaseType")("C++", qname("float"));
  types_[qname("double")] =  asg_module_.attr("BaseType")("C++", qname("double"));
  types_[qname("void")] =  asg_module_.attr("BaseType")("C++", qname("void"));
  types_[qname("...")] =  asg_module_.attr("BaseType")("C++", qname("..."));
  types_[qname("long long")] =  asg_module_.attr("BaseType")("C++", qname("long long"));
  types_[qname("long double")] =  asg_module_.attr("BaseType")("C++", qname("long double"));
  types_[qname("wchar_t")] =  asg_module_.attr("BaseType")("C++", qname("wchar_t"));

  // some GCC extensions...
  types_[qname("__builtin_va_list")] =  asg_module_.attr("BaseType")("C++", qname("__builtin_va_list"));


  // determine canonical filenames
  std::string long_filename = make_full_path(raw_filename_);
  std::string short_filename = make_short_path(raw_filename_, base_path_);

  bpl::object file = files_.get(short_filename);
  if (file)
    file_ = file;
  else
  {
    file_ = sf_module_.attr("SourceFile")(short_filename, long_filename, "C++");
    files_[short_filename] = file_;
  }
}

void ASGTranslator::translate(PT::Node *ptree, Buffer &buffer)
{
  Trace trace("ASGTranslator::translate", Trace::TRANSLATION);
  buffer_ = &buffer;
  ptree->accept(this);
}

void ASGTranslator::visit(PT::NamespaceSpec *spec)
{
  Trace trace("ASGTranslator::visit(NamespaceSpec)", Trace::TRANSLATION);

  bool visible = update_position(spec);
  if (!visible) return;

  PT::Node *identifier = PT::nth<1>(spec);
  std::string name;
  if (identifier) name = std::string(identifier->position(), identifier->length());
  else // anonymous namespace
  {
    name = bpl::extract<std::string>(file_.attr("name"));
    std::string::size_type p = name.rfind('/');
    if (p != std::string::npos) name.erase(0, p + 1);
    name = "{" + name + "}";
  }
  bpl::object module = asg_module_.attr("Module")(file_, lineno_, "namespace", qname(name));
  annotations(module)["comments"] = bpl::list(translate_comments(spec));
  declare(module);
  declare(bpl::tuple(name), module);
  scope_.push(module);
  traverse_body(spec);
  scope_.pop();
}

void ASGTranslator::visit(PT::Declarator *declarator)
{
  Trace trace("ASGTranslator::visit(Declarator)", Trace::TRANSLATION);
  trace << declarator;

  bool visible = update_position(declarator);
  PT::Encoding name = declarator->encoded_name();
  // If the name is qualified, we have already seen a corresponding declaration.
  if (name.is_qualified()) return;
  PT::Encoding type = declarator->encoded_type();
  if (type.is_function())
  {
    bpl::list parameter_types;
    bpl::object return_type = lookup_function_types(type, parameter_types);
    bpl::list parameters;
    PT::List *p = declarator->cdr();
    while (p && p->car() && *p->car() != '(') p = p->cdr();

    for (PT::List *node = static_cast<PT::List *>(PT::nth<1>(p));
	 node && node->car();
	 node = PT::tail(node, 2))
    {
      node->car()->accept(this); // PT::ParameterDeclaration
      parameters.append(parameter_);
    }
    size_t length = (name.front() - 0x80);
    bpl::list qname(std::string(name.begin() + 1, name.begin() + 1 + length));
    bpl::list pre;
    bpl::list post;
    if (type.front() == 'C') post.append("const");

    bpl::object function;
    if (in_class_)
      function = asg_module_.attr("Operation")(file_, lineno_,
                                               "member function",
                                               pre,
                                               return_type,
                                               post,
                                               qname,
                                               name.unmangled());
    else
      function = asg_module_.attr("Function")(file_, lineno_,
                                              "function",
                                              pre,
                                              return_type,
                                              post,
                                              qname,
                                              name.unmangled());
    bpl::extract<bpl::list>(function.attr("parameters"))().extend(parameters);
    if (visible) 
    {
      bpl::list comments;
      if (declaration_)
	comments.extend(translate_comments(declaration_));
      comments.extend(translate_comments(declarator));
      if (comments) annotations(function)["comments"] = bpl::list(comments);
      declare(function);
    }
  }
  else
  {
    bpl::object t = lookup(type);
    size_t length = (name.front() - 0x80);
    bpl::list qname(std::string(name.begin() + 1, name.begin() + 1 + length));

    std::string vtype = scope_.size() ?
      std::string(bpl::extract<std::string>(scope_.top().attr("type"))) :
      "global variable";
    if (vtype == "class" || vtype == "struct" || vtype == "union")
      vtype = "data member";
    else if (vtype == "function") vtype = "local variable";
    bpl::object variable = asg_module_.attr("Variable")(file_, lineno_,
                                                        vtype, qname, t, false);
    if (visible)
    {
      bpl::list comments;
      if (declaration_)
	comments.extend(translate_comments(declaration_));
      comments.extend(translate_comments(declarator));
      if (comments) annotations(variable)["comments"] = bpl::list(comments);
      declare(variable);
    }
  }
}

void ASGTranslator::visit(PT::SimpleDeclaration *declaration)
{
  Trace trace("ASGTranslator::visit(SimpleDeclaration)", Trace::TRANSLATION);
  bool visible = update_position(declaration);
  // Check whether this is a typedef:
  PT::DeclSpec *spec = declaration->decl_specifier_seq();
  // the decl-specifier-seq may contain a class-specifier, i.e.
  // which we need to define first.
  if (spec) spec->accept(this);
  if (spec && spec->is_typedef())
  {
    for (PT::List *d = declaration->declarators(); d; d = PT::tail(d, 2))
    {
      PT::Declarator *declarator = static_cast<PT::Declarator *>(d->car());
      PT::Encoding name = declarator->encoded_name();
      PT::Encoding type = declarator->encoded_type();
      assert(name.is_simple_name());
      size_t length = (name.front() - 0x80);
      bpl::tuple qname(std::string(name.begin() + 1, name.begin() + 1 + length));
      bpl::object alias = lookup(type);
      bpl::object typedef_ = asg_module_.attr("Typedef")(file_, lineno_,
                                                         "typedef",
                                                         qname,
                                                         alias, false);
      if (visible)
      {
        bpl::list comments;
	comments.extend(translate_comments(declaration));
	comments.extend(translate_comments(declarator));
        if (comments) annotations(typedef_)["comments"] = bpl::list(comments);
	declare(typedef_);
      }
      declare(qname, typedef_);
    }
  }
  else if (declaration->declarators())
  {
    // Cache the declaration while traversing the individual declarators;
    // the comments are passed through.
    declaration_ = declaration;
    Walker::visit(declaration->declarators());
    declaration_ = 0;
  }
}

void ASGTranslator::visit(PT::FunctionDefinition *fdef)
{
  Trace trace("ASGTranslator::visit(FunctionDefinition)", Trace::TRANSLATION);
  declaration_ = fdef;
  PT::Node *decl = PT::nth<1>(fdef);
  visit(static_cast<PT::Declarator *>(decl)); // visit the declarator
  declaration_ = 0;
}

void ASGTranslator::visit(PT::ClassSpec *spec)
{
  Trace trace("ASGTranslator::visit(ClassSpec)", Trace::TRANSLATION);
  
  bool visible = update_position(spec);

  std::string key = PT::string(spec->key());
  ClassNameFinder finder;
  bpl::tuple qname = bpl::tuple(finder.name(spec));
  bpl::object class_ = asg_module_.attr("Class")(file_, lineno_, key, qname);
  if (visible)
  {
    annotations(class_)["comments"] = bpl::list(translate_comments(spec));
    declare(class_);
  }
  if (template_parameters_)
  {
    bpl::object type = declare(qname, class_, template_parameters_);
    class_.attr("template") = type;
  }
  else
    declare(qname, class_);
  scope_.push(class_);
  in_class_ = true;
  Walker::traverse_body(spec);
  in_class_ = false;
  scope_.pop();
}

void ASGTranslator::visit(PT::EnumSpec *spec)
{
  Trace trace("ASGTranslator::visit(EnumSpec)", Trace::TRANSLATION);

  bool visible = update_position(spec);
  std::string name;
  
  if (!spec->name()) //anonymous
  {
    PT::Encoding ename = spec->encoded_name();
    size_t length = (ename.front() - 0x80);
    name = std::string(ename.begin() + 1, ename.begin() + 1 + length);
  }
  else name = PT::string(spec->name());

  bpl::list enumerators;
  PT::List *enode = spec->enumerators();
  bpl::object enumerator;
  while (enode)
  {
    // quite a costly way to update the line number...
    update_position(enode);
    PT::Node *penumor = PT::nth<0>(enode);
    if (penumor->is_atom())
    {
      // identifier
      bpl::tuple qname(PT::string(static_cast<PT::Atom *>(penumor)));
      enumerator = asg_module_.attr("Enumerator")(file_, lineno_, qname, "");
      annotations(enumerator)["comments"] = bpl::list(translate_comments(static_cast<PT::Identifier *>(penumor)));
    }
    else
    {
      // identifier = constant-expression
      bpl::tuple qname(PT::string(static_cast<PT::Atom *>(PT::nth<0>(static_cast<PT::List *>(penumor)))));
      // TBD: For now stringify the initializer expression.
      std::string value = PT::reify(PT::nth<2>(static_cast<PT::List *>(penumor)));
      enumerator = asg_module_.attr("Enumerator")(file_, lineno_, qname, value);
    }
    enumerators.append(enumerator);
    enode = PT::tail(enode, 2);
  }
  // Add a dummy enumerator at the end to absorb trailing comments.
//   PT::Node *close = PT::nth<2>(PT::nth<2>(spec));
//   enumerator = ast_kit_.create_enumerator(file_, lineno_,
// 					    AST::ScopedName(std::string("dummy")), "");
//   add_comments(enumerator, static_cast<PT::CommentedAtom *>(close));
//   enumerators.append(enumerator);
  
  bpl::object enum_ = asg_module_.attr("Enum")(file_, lineno_, name, enumerators);
//   add_comments(enum_, spec->get_comments());

  if (visible) declare(enum_);
  declare(bpl::tuple(name), enum_);
}

void ASGTranslator::visit(PT::ElaboratedTypeSpec *type)
{
  Trace trace("ASGTranslator::visit(ElaboratedTypeSpec)", Trace::TRANSLATION);

  // Find the associated symbol and make sure it is translated.
  // FIXME: An elaborated-type-specifier isn't always declared in the present
  //        scope. We should really look up the corresponding type from the
  //        symbol table.
  PT::Encoding name = PT::name(type->name());
//   try
//   {
    bpl::object t = lookup(name);
//   }
//   catch (Python::Object::KeyError const &)
//   {
//     // not yet defined, so declare it here.
//     std::string key = PT::string(type->type());
//     ClassNameFinder finder;
//     bpl::list qname = finder.name(type);
//     bpl::object fwd = asg_module_.attr("Forward")(file_, lineno_, key, qname);
//     declare(qname, fwd);
//   }

//   ST::SymbolSet symbols = lookup(name, ST::Scope::ELABORATED);
//   assert(symbols.size() == 1);
//   ST::Symbol const *symbol = *symbols.begin();
//   ST::Scope *scope = symbol->scope();
}

void ASGTranslator::visit(PT::TemplateDeclaration *templ)
{
  Trace trace("ASGTranslator::visit(TemplateDeclaration)", Trace::TRANSLATION);

  bpl::list parameters;
  if (!PT::nth<2>(templ)->is_atom()) // 'template < > ...' is a specialization.
  {
    for (PT::List *params = static_cast<PT::List *>(PT::nth<2>(templ));
	 params;
	 params = PT::tail(params, 2))
    {
      params->car()->accept(this);      
      parameters.append(parameter_);
    }
    template_parameters_ = parameters;
    // Traverse the declaration.
    PT::nth<4>(templ)->accept(this);
  }
  // Reset, to indicate we are not inside a template declaration.
  template_parameters_ = bpl::list();
}

void ASGTranslator::visit(PT::TypeParameter *param)
{
  Trace trace("ASGTranslator::visit(TypeParameter)", Trace::TRANSLATION);

  PT::Node *typename_ = PT::nth<0>(param);
  PT::Node *name = PT::nth<1>(param);
  bpl::tuple qname(std::string(name->position(), name->length()));
  bpl::object type = create_dependent(qname);
  bpl::list pre(std::string(typename_->position(), typename_->length()));
  bpl::list post;
  parameter_ = asg_module_.attr("Parameter")(pre, type, post, "", "");
}

void ASGTranslator::visit(PT::ParameterDeclaration *param)
{
  Trace trace("ASGTranslator::visit(ParameterDeclaration)", Trace::TRANSLATION);

  PT::DeclSpec *spec = param->decl_specifier_seq();
  // FIXME: extract modifiers and type from decl-specifier-seq
  bpl::list pre;
  bpl::object type = lookup(spec->type());
  bpl::list post;
  std::string name;
  PT::Declarator *declarator = param->declarator();
  if (declarator) name = declarator->encoded_name().unmangled();
  std::string value;
  PT::Node *initializer = param->initializer();
  if (initializer) value = PT::reify(initializer);
  parameter_ = asg_module_.attr("Parameter")(pre, type, post, name, value);
}

template <typename T>
bpl::list ASGTranslator::translate_comments(T *node)
{
  Trace trace("ASGTranslator::translate_comments", Trace::TRANSLATION);
  PTree::List *c = node->get_comments();
  if (!c) return bpl::list();
  
  bpl::list comments;
  bool suspect = false;
  PT::Atom *first = 0;
  PT::Atom *last = 0;
  for (; c; c = c->cdr())
  {
    PT::Atom *current = static_cast<PT::Atom *>(c->car());
    // update position information for this comment
    update_position(c);
    // Check if comment is continued, eg: consecutive C++ comments
    if (std::string("//").compare(0, 2, current->position(), 2) == 0)
    {
      if (!first) first = last = current;
      else if (current->position() - last->end() == 1) last = current;
      else
      {
	std::string comment(first->begin(), last->end() - first->begin());
	comments.append(comment);
	first = last = current;
      }
    }
    else
    {
      // If there is more than one newline and (optional) whitespace separating this 
      // comment's end and the node to which it is attached, it is marked as suspect.
      char const *end = node->begin();
      char const *ptr = current->end() + 1;
      suspect = ptr != end;
      while (ptr != end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n')) ++ptr;
      while (ptr != end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r')) ++ptr;
      std::string comment(current->position(), current->length());
      comments.append(comment);
    }
  }
  if (first)
  {
    char const *end = node->begin();
    char const *ptr = last->end() + 1;
    while (ptr != end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r')) ++ptr;
    suspect = ptr != end;
    std::string comment(first->begin(), last->end() - first->begin());
    comments.append(comment);
  }
  if (suspect) comments.append(bpl::object());
  return comments;
}

bool ASGTranslator::update_position(PT::Node *node)
{
  Trace trace("ASGTranslator::update_position", Trace::TRANSLATION);

  std::string filename;
  lineno_ = buffer_->origin(node->begin(), filename);

  if (filename != raw_filename_)
  {
    if (primary_file_only_)
      // raw_filename_ remains the main file's name
      // and all declarations from elsewhere are ignored
      return false;
    raw_filename_ = filename;

    // determine canonical filenames
    std::string long_filename = make_full_path(raw_filename_);
    std::string short_filename = make_short_path(raw_filename_, base_path_);

    bpl::object file = files_.get(short_filename);
    if (file)
      file_ = file;
    else
    {
      file_ = sf_module_.attr("SourceFile")(short_filename, long_filename, "C++");
      files_[short_filename] = file_;
    }
  }
  return true;
}

bpl::object ASGTranslator::lookup(PT::Encoding const &name)
{
  Trace trace("ASGTranslator::lookup", Trace::TRANSLATION);
  trace << name;
  name_ = name;
  bpl::object type;
  decode_type(name.begin(), type);
  return type;
}

bpl::object ASGTranslator::lookup_function_types(PT::Encoding const &name,
                                                 bpl::list parameters)
{
  Trace trace("ASGTranslator::lookup_function_types", Trace::TRANSLATION);
  trace << name;
  name_ = name;

  PT::Encoding::iterator i = name.begin();
  if (*i == 'C') ++i;
  assert(*i == 'F');
  ++i;
  while (true)
  {
    bpl::object parameter;
    i = decode_type(i, parameter);
    if (parameter) parameters.append(parameter);
    else break;
  }
  ++i; // skip over '_'
  bpl::object return_type;
  i = decode_type(i, return_type);
  return return_type;
}

bpl::object ASGTranslator::declare(bpl::tuple qname, bpl::object declaration)
{
  Trace trace("ASGTranslator::declare", Trace::TRANSLATION);
  bpl::object type = asg_module_.attr("Declared")("C++", qname, declaration);
  types_[qname] = type;
  return type;
}

bpl::object ASGTranslator::declare(bpl::tuple qname,
                                   bpl::object declaration,
                                   bpl::list parameters)
{
  Trace trace("ASGTranslator::declare", Trace::TRANSLATION);
  bpl::object type = asg_module_.attr("Template")("C++", qname, declaration, parameters);
  types_[qname] = type;
  return type;
}

bpl::object ASGTranslator::create_dependent(bpl::tuple qname)
{
  Trace trace("ASGTranslator::create_dependent", Trace::TRANSLATION);
  bpl::object type = asg_module_.attr("Dependent")("C++", qname);
  return type;
}


void ASGTranslator::declare(bpl::object declaration)
{
  if (scope_.size())
    bpl::extract<bpl::list>(scope_.top().attr("declarations"))().append(declaration);
  else
    declarations_.append(declaration);
}

// FIXME: this ought to be part of SymbolLookup::Type.
PT::Encoding::iterator ASGTranslator::decode_name(PT::Encoding::iterator i,
                                                  std::string &name)
{
  Trace trace("ASGTranslator::decode_name", Trace::TRANSLATION);
  size_t length = *i++ - 0x80;
  name = std::string(length, '\0');
  std::copy(i, i + length, name.begin());
  i += length;
  return i;
}

PT::Encoding::iterator ASGTranslator::decode_type(PT::Encoding::iterator i,
                                                  bpl::object type)
{
  Trace trace("ASGTranslator::decode_type", Trace::TRANSLATION);
  bpl::list premod, postmod;
  std::string name;
  bpl::object base;

  // Loop forever until broken
  while (i != name_.end() && !name.length() && !base)
  {
    int c = *i++;
    switch (c)
    {
      case 'P':
	postmod.insert(0, "*");
	break;
      case 'R':
 	postmod.insert(0, "&");
 	break;
      case 'S':
	premod.append("signed");
	break;
      case 'U':
	premod.append("unsigned");
	break;
      case 'C':
	premod.append("const");
	break;
      case 'V':
	premod.append("volatile");
	break;
      case 'A':
      {
	std::string array("[");
	while (*i != '_') array.push_back(*i++);
	array.push_back(']');
	++i;
	premod.append(array);
	  break;
      }
      case '*':
      {
        bpl::list qname;
  	qname.append("*");
  	base = asg_module_.attr("Dependent")(qname);
  	break;
      }
      case 'i':
	name = "int";
	break;
      case 'v':
	name = "void";
	break;
      case 'b':
 	name = "bool";
 	break;
      case 's':
	name = "short";
	break;
      case 'c':
	name = "char";
	break;
      case 'w':
 	name = "wchar_t";
 	break;
      case 'l':
	name = "long";
	break;
      case 'j':
	name = "long long";
	break;
      case 'f':
	name = "float";
	break;
      case 'd':
	name = "double";
	break;
      case 'r':
	name = "long double";
	break;
      case 'e':
	name = "...";
	break;
      case '?':
// 	name = "int";
	break;
      case 'Q':
	i = decode_qtype(i, base);
 	break;
      case '_':
	--i;
	type = bpl::object();
	return i; // end of func params
      case 'F':
	i = decode_func_ptr(i, base, postmod);
	break;
      case 'T':
 	i = decode_template(i, base);
 	break;
      case 'M':
 	// Pointer to member. Format is same as for named types
 	i = decode_name(i, name);
	name += "::*";
 	break;
      default:
	if (c > 0x80)
	{
	  --i;
	  i = decode_name(i, name);
	  break;
	}
    } // switch
  } // while
  if (!base && name.empty())
  {
    type = bpl::object();
    return i;
  }
  if (!base) base = types_[bpl::tuple(name)];
  if (!bpl::len(premod) && !bpl::len(postmod)) type = base;
  else type = asg_module_.attr("Modifier")(base, premod, postmod);
  return i;
}

PT::Encoding::iterator 
ASGTranslator::decode_qtype(PT::Encoding::iterator i, bpl::object type)
{
  Trace trace("ASGTranslator::decode_qtype", Trace::TRANSLATION);
  // Qualified type: first is num of scopes, each a name.
  size_t scopes = *i++ - 0x80;
  bpl::list qname;
  bpl::list parameters;
  while (scopes--)
  {
    if (*i >= 0x80) // simple name
    {
      std::string name;
      i = decode_name(i, name);
      qname.append(name);
    }
    else if (*i == 'T') // template
    {
      ++i;
      std::string name;
      i = decode_name(i, name);
      PT::Encoding::iterator end = i;
      end += *i++ - 0x80;
      while (i <= end)
      {
        bpl::object parameter;
	i = decode_type(i, parameter);
	parameters.append(parameter);
      }
      qname.append(name);
    }
    else
    {
      std::cerr << "Error: unexpected character " << *i << std::endl;
      assert(0);
    }
  }
  try
  {
    type = asg_module_[bpl::tuple(qname)];
  }
  catch (...)
  {
    // Ignore error, and return an Unknown instead
    type = asg_module_.attr("Unknown")(qname);
    return i;
  }
  // If the type is a template, then parameterize it with the params found
  // in the T decoding
  if (!bpl::len(parameters))
  {
    std::cerr << "TODO: handle template parameters " << std::endl;
//     Types::Declared* declared = dynamic_cast<Types::Declared*>(baseType);
//     AST::Class* tempclas = declared ? dynamic_cast<AST::Class*>(declared->declaration()) : 0;
//     Types::Template* templType = tempclas ? tempclas->template_type() : 0;
//     if (templType && types.size())
//     {
//       return new Types::Parameterized(templType, types);
//     }
  }
  return i;
}

PT::Encoding::iterator 
ASGTranslator::decode_template(PT::Encoding::iterator i, bpl::object)
{
  Trace trace("ASGTranslator::decode_template", Trace::TRANSLATION);
  std::string name;
  i = decode_name(i, name);
  PT::Encoding::iterator end = i;
  end += *i++ - 0x80;
  bpl::list parameters;
  while (i <= end)
  {
    bpl::object parameter;
    i = decode_type(i, parameter);
    if (parameter) parameters.append(parameter);
    else break;
  }

  std::cerr << "TODO: ASGTranslator::decode_template" << std::endl;
  return i;
}

PT::Encoding::iterator ASGTranslator::decode_func_ptr(PT::Encoding::iterator i,
                                                      bpl::object type,
                                                      bpl::list postmod)
{
  Trace trace("ASGTranslator::decode_func_ptr", Trace::TRANSLATION);
  // Function ptr. Encoded same as function
  bpl::list premod;
  // Move * from postmod to funcptr's premod. This makes the output be
  // "void (*convert)()" instead of "void (convert)()*"
  if (bpl::len(postmod) > 0 && postmod[0] == bpl::object("*"))
    premod.append(postmod.pop(0));
  bpl::list parameters;
  while (true)
  {
    bpl::object parameter;
    i = decode_type(i, parameter);
    if (parameter) parameters.append(parameter);
    else break;
  }
  ++i; // skip over '_'
  i = decode_type(i, type);
  type = asg_module_.attr("FunctionType")(type, premod, parameters);
  return i;
}
