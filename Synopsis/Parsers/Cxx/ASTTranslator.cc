//
// Copyright (C) 2005 Stefan Seefeld
// All rights reserved.
// Licensed to the public under the terms of the GNU LGPL (>= 2),
// see the file COPYING for details.
//

#include "ASTTranslator.hh"
#include "TypeTranslator.hh"
#include <Synopsis/Trace.hh>
#include <Synopsis/PTree/Writer.hh> // for PTree::reify
#include <Synopsis/PTree/Display.hh> // for PTree::display (debugging...)
#include <Synopsis/SymbolTable/Display.hh> // for SymbolTable::display (debugging...)
#include <Synopsis/Python/Object.hh>
#include <Support/path.hh>

using Synopsis::Token;
using Synopsis::Trace;
namespace PT = Synopsis::PTree;
namespace ST = Synopsis::SymbolTable;

namespace
{
//. Extract the name of the class as a qualified name.
//. The name is either an identifier, a (qualified) name,
//. or nil, in which case we use the synthetic name generated by
//. the parser.
//. FIXME: Don't use the name for anonymous classes. It is wrong
//.        since multiple generated names will clash across multiple
//.        compilation units.
class ClassNameFinder : PT::Visitor
{
public:
  AST::ScopedName name(PT::ClassSpec *spec)
  {
    if (spec->name()) spec->name()->accept(this);
    else
    {
      PT::Encoding ename = spec->encoded_name();
      size_t length = (ename.front() - 0x80);
      name_ = std::string(ename.begin() + 1, ename.begin() + 1 + length);

    }
    return name_;
  }
  AST::ScopedName name(PT::ElaboratedTypeSpec *spec)
  {
    spec->name()->accept(this);
    return name_;
  }
private:
  virtual void visit(PT::Identifier *id) { name_ = PT::string(id);}
  virtual void visit(PT::Name *node)
  {
    PT::Encoding name = node->encoded_name();
    for (PT::Encoding::name_iterator next = name.begin_name();
	 next != name.end_name();
	 ++next)
      name_.append(name.unmangled());
  }

  AST::ScopedName name_;
};

}

ASTTranslator::ASTTranslator(ST::Scope *scope,
			     std::string const &filename,
			     std::string const &base_path, bool primary_file_only,
			     Synopsis::AST::AST ast, bool v, bool d)
  : Walker(scope),
    ast_(ast),
    sf_kit_("C++"),
    raw_filename_(filename),
    base_path_(base_path),
    primary_file_only_(primary_file_only),
    lineno_(0),
    types_(ast_.types(), v, d),
    in_class_(false),
    verbose_(v),
    debug_(d) 
{
  Trace trace("ASTTranslator::ASTTranslator", Trace::TRANSLATION);

  // determine canonical filenames
  std::string long_filename = make_full_path(raw_filename_);
  std::string short_filename = make_short_path(raw_filename_, base_path_);

  AST::SourceFile file = ast_.files().get(short_filename);
  if (file)
    file_ = file;
  else
  {
    file_ = sf_kit_.create_source_file(short_filename, long_filename);
    ast_.files().set(short_filename, file_);
  }
}

void ASTTranslator::translate(PT::Node *ptree, Buffer &buffer)
{
  Trace trace("ASTTranslator::translate", Trace::TRANSLATION);
  buffer_ = &buffer;
  ptree->accept(this);
}

void ASTTranslator::visit(PT::NamespaceSpec *spec)
{
  Trace trace("ASTTranslator::visit(NamespaceSpec)", Trace::TRANSLATION);

  bool visible = update_position(spec);
  if (!visible) return;

  PT::Node *identifier = PT::nth<1>(spec);
  std::string name;
  if (identifier) name = std::string(identifier->position(), identifier->length());
  else // anonymous namespace
  {
    name = file_.name();
    std::string::size_type p = name.rfind('/');
    if (p != std::string::npos) name.erase(0, p + 1);
    name = "{" + name + "}";
  }
  AST::ScopedName qname = name;
  AST::Module module = ast_kit_.create_module(file_, lineno_,
						"namespace", qname);
  Python::List comments = translate_comments(spec);
  Python::List annotations = module.annotations().get("comments");
  annotations.extend(comments);
  declare(module);
  types_.declare(qname, module);
  scope_.push(module);
  traverse_body(spec);
  scope_.pop();
}

void ASTTranslator::visit(PT::Declarator *declarator)
{
  Trace trace("ASTTranslator::visit(Declarator)", Trace::TRANSLATION);
  trace << declarator;

  bool visible = update_position(declarator);
  PT::Encoding name = declarator->encoded_name();
  // If the name is qualified, we have already seen a corresponding declaration.
  if (name.is_qualified()) return;
  PT::Encoding type = declarator->encoded_type();
  if (type.is_function())
  {
    AST::TypeList parameter_types;
    AST::Type return_type = types_.lookup_function_types(type, parameter_types);
    AST::Function::Parameters parameters;
    PT::List *p = declarator->cdr();
    while (p && p->car() && *p->car() != '(') p = p->cdr();

    for (PT::List *node = static_cast<PT::List *>(PT::nth<1>(p));
	 node && node->car();
	 node = PT::tail(node, 2))
    {
      node->car()->accept(this); // PT::ParameterDeclaration
      parameters.append(parameter_);
    }
    size_t length = (name.front() - 0x80);
    AST::ScopedName qname(std::string(name.begin() + 1, name.begin() + 1 + length));
    AST::Modifiers pre;
    AST::Modifiers post;
    if (type.front() == 'C') post.append("const");

    AST::Function function;
    if (in_class_)
      function = ast_kit_.create_operation(file_, lineno_,
                                           "member function",
                                           pre,
                                           return_type,
                                           post,
                                           qname,
                                           name.unmangled());
    else
      function = ast_kit_.create_function(file_, lineno_,
                                          "function",
                                          pre,
                                          return_type,
                                          post,
                                          qname,
                                          name.unmangled());
    function.parameters().extend(parameters);
    if (visible) 
    {
      Python::List comments;
      if (declaration_)
	comments.extend(translate_comments(declaration_));
      comments.extend(translate_comments(declarator));
      if (comments)
	function.annotations().set("comments", comments);
      declare(function);
    }
  }
  else
  {
    AST::Type t = types_.lookup(type);
    size_t length = (name.front() - 0x80);
    AST::ScopedName qname(std::string(name.begin() + 1, name.begin() + 1 + length));

    std::string vtype = scope_.size() ? scope_.top().type() : "global variable";
    if (vtype == "class" || vtype == "struct" || vtype == "union")
      vtype = "data member";
    else if (vtype == "function") vtype = "local variable";
    AST::Variable variable = ast_kit_.create_variable(file_, lineno_,
                                                      vtype, qname, t, false);
    if (visible)
    {
      Python::List comments;
      if (declaration_)
	comments.extend(translate_comments(declaration_));
      comments.extend(translate_comments(declarator));
      if (comments)
	variable.annotations().set("comments", comments);
      declare(variable);
    }
  }
}

void ASTTranslator::visit(PT::SimpleDeclaration *declaration)
{
  Trace trace("ASTTranslator::visit(SimpleDeclaration)", Trace::TRANSLATION);
  bool visible = update_position(declaration);
  // Check whether this is a typedef:
  PT::DeclSpec *spec = declaration->decl_specifier_seq();
  // the decl-specifier-seq may contain a class-specifier, i.e.
  // which we need to define first.
  if (spec) spec->accept(this);
  if (spec && spec->is_typedef())
  {
    for (PT::List *d = declaration->declarators(); d; d = PT::tail(d, 2))
    {
      PT::Declarator *declarator = static_cast<PT::Declarator *>(d->car());
      PT::Encoding name = declarator->encoded_name();
      PT::Encoding type = declarator->encoded_type();
      assert(name.is_simple_name());
      size_t length = (name.front() - 0x80);
      AST::ScopedName qname(std::string(name.begin() + 1, name.begin() + 1 + length));
      AST::Type alias = types_.lookup(type);
      AST::Typedef typedef_ = ast_kit_.create_typedef(file_, lineno_,
                                                      "typedef",
                                                      qname,
                                                      alias, false);
      if (visible)
      {
	Python::List comments;
	comments.extend(translate_comments(declaration));
	comments.extend(translate_comments(declarator));
	typedef_.annotations().set("comments", comments);
	declare(typedef_);
      }
      types_.declare(qname, typedef_);
    }
  }
  else if (declaration->declarators())
  {
    // Cache the declaration while traversing the individual declarators;
    // the comments are passed through.
    declaration_ = declaration;
    Walker::visit(declaration->declarators());
    declaration_ = 0;
  }
}

void ASTTranslator::visit(PT::FunctionDefinition *fdef)
{
  Trace trace("ASTTranslator::visit(FunctionDefinition)", Trace::TRANSLATION);
  declaration_ = fdef;
  PT::Node *decl = PT::nth<1>(fdef);
  visit(static_cast<PT::Declarator *>(decl)); // visit the declarator
  declaration_ = 0;
}

void ASTTranslator::visit(PT::ClassSpec *spec)
{
  Trace trace("ASTTranslator::visit(ClassSpec)", Trace::TRANSLATION);
  
  bool visible = update_position(spec);

  std::string key = PT::string(spec->key());
  ClassNameFinder finder;
  AST::ScopedName qname = finder.name(spec);
  AST::Class class_ = ast_kit_.create_class(file_, lineno_, key, qname);
  if (visible)
  {
    Python::List comments;
    comments.extend(translate_comments(spec));
    class_.annotations().set("comments", comments);
    declare(class_);
  }
  if (template_parameters_)
  {
    AST::Type type = types_.declare(qname, class_, template_parameters_);
    class_.set_template(type);
  }
  else
    types_.declare(qname, class_);
  scope_.push(class_);
  in_class_ = true;
  Walker::traverse_body(spec);
  in_class_ = false;
  scope_.pop();
}

void ASTTranslator::visit(PT::EnumSpec *spec)
{
  Trace trace("ASTTranslator::visit(EnumSpec)", Trace::TRANSLATION);

  bool visible = update_position(spec);
  std::string name;
  
  if (!spec->name()) //anonymous
  {
    PT::Encoding ename = spec->encoded_name();
    size_t length = (ename.front() - 0x80);
    name = std::string(ename.begin() + 1, ename.begin() + 1 + length);
  }
  else name = PT::string(spec->name());

  AST::Enumerators enumerators;
  PT::List *enode = spec->enumerators();
  AST::Enumerator enumerator;
  while (enode)
  {
    // quite a costly way to update the line number...
    update_position(enode);
    PT::Node *penumor = PT::nth<0>(enode);
    if (penumor->is_atom())
    {
      // identifier
      AST::ScopedName qname(PT::string(static_cast<PT::Atom *>(penumor)));
      enumerator = ast_kit_.create_enumerator(file_, lineno_, qname, "");
      Python::List comments = 
	translate_comments(static_cast<PT::Identifier *>(penumor));
      enumerator.annotations().set("comments", comments);
    }
    else
    {
      // identifier = constant-expression
      AST::ScopedName qname(PT::string(static_cast<PT::Atom *>(PT::nth<0>(static_cast<PT::List *>(penumor)))));
      // TBD: For now stringify the initializer expression.
      std::string value = PT::reify(PT::nth<2>(static_cast<PT::List *>(penumor)));
      enumerator = ast_kit_.create_enumerator(file_, lineno_, qname, value);
    }
    enumerators.append(enumerator);
    enode = PT::tail(enode, 2);
  }
  // Add a dummy enumerator at the end to absorb trailing comments.
//   PT::Node *close = PT::nth<2>(PT::nth<2>(spec));
//   enumerator = ast_kit_.create_enumerator(file_, lineno_,
// 					    AST::ScopedName(std::string("dummy")), "");
//   add_comments(enumerator, static_cast<PT::CommentedAtom *>(close));
//   enumerators.append(enumerator);
  
  // Create AST.Enum object
  AST::Enum enum_ = ast_kit_.create_enum(file_, lineno_, name, enumerators);
//   add_comments(enum_, spec->get_comments());

  if (visible) declare(enum_);
  types_.declare(AST::ScopedName(name), enum_);
}

void ASTTranslator::visit(PT::ElaboratedTypeSpec *type)
{
  Trace trace("ASTTranslator::visit(ElaboratedTypeSpec)", Trace::TRANSLATION);

  // Find the associated symbol and make sure it is translated.
  // FIXME: An elaborated-type-specifier isn't always declared in the present
  //        scope. We should really look up the corresponding type from the
  //        symbol table.
  PT::Encoding name = PT::name(type->name());
  try
  {
    AST::Type type = types_.lookup(name);
  }
  catch (Python::Object::KeyError const &)
  {
    // not yet defined, so declare it here.
    std::string key = PT::string(type->type());
    ClassNameFinder finder;
    AST::ScopedName qname = finder.name(type);
    AST::Forward fwd = ast_kit_.create_forward(file_, lineno_, key, qname);
    types_.declare(qname, fwd);
  }
//   ST::SymbolSet symbols = lookup(name, ST::Scope::ELABORATED);
//   assert(symbols.size() == 1);
//   ST::Symbol const *symbol = *symbols.begin();
//   ST::Scope *scope = symbol->scope();
}

void ASTTranslator::visit(PT::TemplateDeclaration *templ)
{
  Trace trace("ASTTranslator::visit(TemplateDeclaration)", Trace::TRANSLATION);

  AST::Template::Parameters parameters;
  if (!PT::nth<2>(templ)->is_atom()) // 'template < > ...' is a specialization.
  {
    for (PT::List *params = static_cast<PT::List *>(PT::nth<2>(templ));
	 params;
	 params = PT::tail(params, 2))
    {
      params->car()->accept(this);      
      parameters.append(parameter_);
    }
    template_parameters_ = parameters;
    // Traverse the declaration.
    PT::nth<4>(templ)->accept(this);
  }
  // Reset, to indicate we are not inside a template declaration.
  template_parameters_ = AST::Template::Parameters();
}

void ASTTranslator::visit(PT::TypeParameter *param)
{
  Trace trace("ASTTranslator::visit(TypeParameter)", Trace::TRANSLATION);

  PT::Node *typename_ = PT::nth<0>(param);
  PT::Node *name = PT::nth<1>(param);
  AST::ScopedName qname(std::string(name->position(), name->length()));
  AST::Type type = types_.create_dependent(qname);
  AST::Modifiers pre(std::string(typename_->position(), typename_->length()));
  AST::Modifiers post;
  parameter_ = ast_kit_.create_parameter(pre, type, post, "", "");
}

void ASTTranslator::visit(PT::ParameterDeclaration *param)
{
  Trace trace("ASTTranslator::visit(ParameterDeclaration)", Trace::TRANSLATION);

  PT::DeclSpec *spec = param->decl_specifier_seq();
  // FIXME: extract modifiers and type from decl-specifier-seq
  AST::Modifiers pre;
  AST::Type type = types_.lookup(spec->type());
  AST::Modifiers post;
  std::string name;
  PT::Declarator *declarator = param->declarator();
  if (declarator) name = declarator->encoded_name().unmangled();
  std::string value;
  PT::Node *initializer = param->initializer();
  if (initializer) value = PT::reify(initializer);
  parameter_ = ast_kit_.create_parameter(pre, type, post, name, value);
}

template <typename T>
Python::List ASTTranslator::translate_comments(T *node)
{
  Trace trace("ASTTranslator::translate_comments", Trace::TRANSLATION);
  PTree::List *c = node->get_comments();
  if (!c) return Python::List();
  
  Python::List comments;
  bool suspect = false;
  PT::Atom *first = 0;
  PT::Atom *last = 0;
  for (; c; c = c->cdr())
  {
    PT::Atom *current = static_cast<PT::Atom *>(c->car());
    // update position information for this comment
    update_position(c);
    // Check if comment is continued, eg: consecutive C++ comments
    if (std::string("//").compare(0, 2, current->position(), 2) == 0)
    {
      if (!first) first = last = current;
      else if (current->position() - last->end() == 1) last = current;
      else
      {
	std::string comment(first->begin(), last->end() - first->begin());
	comments.append(comment);
	first = last = current;
      }
    }
    else
    {
      // If there is more than one newline and (optional) whitespace separating this 
      // comment's end and the node to which it is attached, it is marked as suspect.
      char const *end = node->begin();
      char const *ptr = current->end() + 1;
      suspect = ptr != end;
      while (ptr != end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r' || *ptr == '\n')) ++ptr;
      while (ptr != end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r')) ++ptr;
      std::string comment(current->position(), current->length());
      comments.append(comment);
    }
  }
  if (first)
  {
    char const *end = node->begin();
    char const *ptr = last->end() + 1;
    while (ptr != end && (*ptr == ' ' || *ptr == '\t' || *ptr == '\r')) ++ptr;
    suspect = ptr != end;
    std::string comment(first->begin(), last->end() - first->begin());
    comments.append(comment);
  }
  if (suspect) comments.append(Python::Object());
  return comments;
}

bool ASTTranslator::update_position(PT::Node *node)
{
  Trace trace("ASTTranslator::update_position", Trace::TRANSLATION);

  std::string filename;
  lineno_ = buffer_->origin(node->begin(), filename);

  if (filename != raw_filename_)
  {
    if (primary_file_only_)
      // raw_filename_ remains the main file's name
      // and all declarations from elsewhere are ignored
      return false;
    raw_filename_ = filename;

    // determine canonical filenames
    std::string long_filename = make_full_path(raw_filename_);
    std::string short_filename = make_short_path(raw_filename_, base_path_);

    AST::SourceFile file = ast_.files().get(short_filename);
    if (file)
      file_ = file;
    else
    {
      file_ = sf_kit_.create_source_file(short_filename, long_filename);
      ast_.files().set(short_filename, file_);
    }
  }
  return true;
}

// FIXME: AST should derive from Scope (a global scope IsA scope...)
//        This method exists because currently it is not.
void ASTTranslator::declare(AST::Declaration declaration)
{
  if (scope_.size())
    scope_.top().declarations().append(declaration);
  else
    ast_.declarations().append(declaration);    
}
