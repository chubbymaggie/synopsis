#!/usr/bin/env python
#
# $Id: gen-emulations,v 1.2 2002/09/24 15:11:51 chalky Exp $
#
# This file is a part of Synopsis.
# Copyright (C) 2002 Stephen Davies
#
# Synopsis is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
# 02111-1307, USA.

# This script finds compilers in the system and generates a file containing
# the info for Synopsis. The generated file should be installed as
# $pythonlib/site-packages/Synopsis/ConfigCxx.py (??)

import sys, os, re, string
from Synopsis.Core import Util

usage = \
"""Usage: gen-emulations <output-filename> [ <compiler1> <compiler2> ... ]

Generates compiler emulation config for the given compilers, storing the
output in the given filename.

If no compilers are specified, then a default set of common compilers are
tried."""

# The list of default compilers. Note that the C syntax is not quite
# supported, so including a bazillion different C compilers is futile.
default_compilers = [
    'cc', 'c++', 'gcc', 'g++', 'g++-2.95', 'g++-3.0', 'g++-3.1', 'g++-3.2'
]


class CompilerMap:
    def __init__(self, infos):
	self.infos = infos # dict of string to CompilerInfo

def main():
    """The main function - parses the arguments and controls the program"""
    if len(sys.argv) < 2:
	print usage
	return

    filename = sys.argv[1]
    print "Filename is ", filename
    if len(sys.argv) > 2:
	compilers = sys.argv[2:]
    else:
	compilers = default_compilers
    print "compilers are:", compilers

    infos = get_compiler_infos(compilers)
    if not infos:
	print "No compilers found. Not writing file!"
	return

    file = open(filename, 'wt')
    write_compiler_infos(infos, file)
    file.close()

    print "Found info about the following compilers:"
    print string.join(map(lambda x: x[0], infos), ', ')

def get_compiler_infos(compilers):
    infos = filter(None, map(find_compiler_info, compilers))
    return infos

def write_compiler_infos(infos, file):
    writer = Util.PyWriter(file)
    writer.write_top('"""This file contains info about compilers for use by '+
    'Synopsis.\nSee "gen-emulations" for info on customizing this list."""\n')
    writer.ensure_struct()
    writer.write('class CompilerMap:\n')
    writer.indent()
    writer.write('infos = {\n')
    writer.indent()
    ccomma = 0
    for compiler, paths, macros in infos:
	if ccomma: writer.write(",\n")
	else: ccomma = 1
	writer.write("'%s' : struct( paths = "%compiler)
	writer.write_long_list(paths)
	writer.write(", macros = {\n")
	writer.indent()
	comma = 0
	items = macros.items()
	items.sort()
	for key, value in items:
	    if comma: writer.write(",\n'%s' : '%s'" % (key, value))
	    else:
		writer.write("'%s' : '%s'" % (key, value))
		comma = 1
	writer.write("\n")
	writer.outdent()
	writer.write("} )")
    writer.outdent()
    writer.write("\n}\n")
    writer.outdent()
    writer.flush()
    
    

re_specs = re.compile('^Reading specs from (.*/)lib/gcc-lib/(.*)/([0-9]+\.[0-9]+\.[0-9]+)/specs$')
re_version = re.compile('([0-9]+)\.([0-9]+)\.([0-9]+)')

def find_compiler_info(compiler):
    print "Finding info for '%s'"%compiler

    # Run the compiler with -v and get first line to stderr (assumes gcc!!!)
    cin, out,err = os.popen3(compiler + " -v")
    version = err.readline().rstrip()
    cin.close()
    out.close()
    err.close()

    # Parse the first line for the 'specs' path - all the info we need is in
    # the path
    mo = re_specs.match(version)
    if not mo:
	print "Warning: unrecognised version string '%s'"%version
	return None
    prefix, hosttype, version = mo.groups()

    # Construct a list of include paths
    paths = []
    # The version-specific dir
    paths.append('%slib/gcc-lib/%s/%s/include'%(prefix, hosttype, version))
    # For some reason (Debian?) has 2.x as g++-3 and 3.x as g++-v3
    if version[0] == '3':
	paths.append(prefix + 'include/g++-v3')
	paths.append(prefix + 'include/g++-v3/bits')
    else:
	paths.append(prefix + 'include/g++-3')
	paths.append(prefix + 'include/g++-3/bits')
    # The prefix include
    paths.append(prefix + 'include')
    # The /usr/include if different
    if prefix != '/usr/':
	paths.append('/usr/include')

    # As for macros, these are somewhat contrived as I don't have many
    # compilers/architectures to test with ;) However, I did derive them from
    # the gcc sources (CVS mid sep '02).
    # Defines to the empty string are just defines
    # Defines to None are undefines (removes previous definition)
    macros = {}

    v1, v2, v3 = re_version.match(version).groups()
    macros['__GNUC__'] = str(v1)
    macros['__GNUC_MINOR__'] = str(v2)
    macros['__GNUC_PATCHLEVEL__'] = str(v3)
    macros['__STDC__'] = '1'
    macros['__STDC_VERSION__'] = '199409L'
    macros['__GNUG__'] = ''
    macros['__cplusplus__'] = '1' # STD says '199711L', but gcc isn't fully compliant...
    macros['__VERSION__'] = version
    macros['unix'] = ''
    # These last three are architecture dependant:
    macros['__ELF__'] = ''
    macros['linux'] = ''
    macros['system'] = 'posix'

    return (compiler, paths, macros)
    


if __name__ == '__main__': main()

