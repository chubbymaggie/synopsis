#!/usr/bin/env python
# Qt GUI for Synopsis
# Copyright (c) 2001 by Stephen Davies
#
# Tested on Debian unstable with python-pyqt package (and dependencies)
# This appears to be using Qt 2.0


import sys, pickle, Synopsis, cStringIO
from qt import *
from Synopsis.Core import AST
from Synopsis.Formatter.ASCII import ASCIIFormatter


class BrowseWindow (QSplitter):
    """A window that browses a given .syn file"""
    def __init__(self, parent, filename, global_decl):
	QSplitter.__init__(self, parent)
	self.filename = filename
	self.global_decl = global_decl

	self.setCaption("'%s' - Browse"%filename)

	# Split up the GUI
	splitV = QSplitter(Qt.Vertical, self)

	# Create a top-left listview for the packages
	self.packages = QListView(splitV)
	self.packages.setMinimumSize(150,100)
	self.packages.addColumn("Name")

	# Create a bottom-left listview for the other stuff
	self.listview = QListView(splitV)
	self.listview.setMinimumSize(150,300)
	self.listview.addColumn("Name")
	self.listview.addColumn("Type")

	# Create a textbrowser to show info about selected stuff
	# This could be just QTextEdit or something I guess... :)
	self.textview = QTextBrowser(self)
	self.textview.setMinimumSize(500,350)
	self.textview.setTextFormat(Qt.RichText)


	# Create the fillers. The first only displays a few types
	self.packfiller = ListFiller(self, self.packages, (
	    'Package', 'Module', 'Namespace', 'Global'))
	self.packfiller.auto_open = 3
	self.listfiller = ListFiller(self, self.listview)
	if ast: self.packfiller.visitAST(ast)

	# Connect things up
	self.connect(self.packages, SIGNAL('selectionChanged(QListViewItem*)'), self.showPackage)
	self.connect(self.listview, SIGNAL('selectionChanged(QListViewItem*)'), self.showDecl)
	self.connect(self.listview, SIGNAL('expanded(QListViewItem*)'), self.selfishExpansion)

	self.textview.setText("<i>Select a package/namespace to view from the left.")
	self.packfiller.fillFrom(global_decl)

	#self.show()

    def showPackage(self, item):
	"""Show a given package (by item)"""
	decl = self.packfiller.map[item]
	# Fill the main list
	self.listfiller.clear()
	self.listfiller.fillFrom(decl)
	# Grab the comments and put them in the text view
	os = cStringIO.StringIO()
	for comment in decl.comments():
	    os.write(comment.text())
	    os.write('<hr>')
	self.textview.setText(os.getvalue())

    def showDecl(self, item):
	"""Show a given declaration (by item)"""
	decl = self.listfiller.map[item]
	# Here we use ASCIIFormatter to quickly get us *something* to display
	# :)
	os = cStringIO.StringIO()
	os.write('<pre>')
	formatter = ASCIIFormatter(os)
	formatter.set_scope(decl.name())
	decl.accept(formatter)
	self.textview.setText(os.getvalue())

    def selfishExpansion(self, item):
	"""Selfishly makes item the only expanded node"""
	if not item.parent(): return
	iter = item.parent().firstChild()
	while iter:
	    if iter != item: self.listview.setOpen(iter, 0)
	    iter = iter.nextSibling()

class Action:
    """A Synopsis Action, ie: parsing, linking, formatting etc"""
    def __init__(self, x, y, name):
	self.__x = x
	self.__y = y
	self.__name = name
    
    def x(self): return self.__x
    def y(self): return self.__y
    def pos(self): return self.__x, self.__y
    def move_to(self, x, y): self.__x = x; self.__y = y
    def move_by(self, dx, dy): self.__x = self.__x+dx; self.__y = self.__y+dy
    def name(self): return self.__name
    def set_name(self, name): self.__name = name

class ActionManager:
    """Manages the actions in a project"""
    class Listener:
	def action_added(self, action): pass
	def action_moved(self, action): pass
    def __init__(self):
	self.__actions = []
	self.__listeners = []
    def add_listener(self, l):
	self.__listeners.append(l)
    def fire(self, signal, *args):
	for l in self.__listeners:
	    apply(getattr(l, signal), args)
    def add_action(self, action):
	self.__actions.append(action)
	self.fire('action_added', action)
    def move_action(self, action, x, y):
	action.move_to(x, y)
	self.fire('action_moved', action)
    def move_action_by(self, action, dx, dy):
	action.move_by(dx, dy)
	self.fire('action_moved', action)

class CanvasStrategy:
    "An interface for a strategy to handle mouse events"
    def __init__(self, canvas, view):
	self.canvas = canvas
	self.view = view
    def reset(self): pass
    def set(self): pass
    def press(self, event): pass
    def release(self, event): pass
    def move(self, event): pass

class SelectionStrategy (CanvasStrategy):
    def __init__(self, canvas, view):
	CanvasStrategy.__init__(self, canvas, view)
	self.__drag_action = None
	self.__icon = None
	self.__last = None

    def reset(self):
	self.__drag_item = None

    def press(self, event):
	action = self.canvas.get_action_at(event.x(), event.y())
	if action:
	    self.__drag_action = action
	    self.__last = QPoint(event.pos())
	    
    def release(self, event):
	if self.__drag_action:
	    self.__drag_action = None
	    
    def move(self, event):
	if not self.__drag_action: return
	dx = event.x() - self.__last.x()
	dy = event.y() - self.__last.y()
	self.view.actions.move_action_by(self.__drag_action, dx, dy)
	self.__last = QPoint(event.pos())

class ConnectStrategy (CanvasStrategy):
    def set(self): print "hello"
    def reset(self): print "bye"

class AddActionStrategy (CanvasStrategy):
    def set(self):
	self.action = Action(10, 10, "new action")
	self.view.actions.add_action(self.action)
	print "add action"
	self.view.viewport().setMouseTracking(1)
	print self.view.viewport().hasMouseTracking()

    def reset(self):
	print "clean up action"
	self.view.viewport().setMouseTracking(0)

    def move(self, event):
	print "moving"
	self.view.actions.move_action(self.action, event.x(), event.y())

    def release(self, event):
	print "create an icon here"
	self.view.window.setMode('select')
	
class ActionCanvas (QCanvas):
    """Extends QCanvas to automatically fill and update the canvas when
    notified of events by an ActionManager"""
    def __init__(self, actions, parent):
	QCanvas.__init__(self, parent)
	self.actions = actions
	self._item_to_action_map = {}
	self._action_to_icon_map = {}

	self.actions.add_listener(self)

    def get_action_at(self, x, y):
	"Returns the Action (if any) at the given coordinates"
	items = self.collisions(QPoint(x, y))
	if items and self._item_to_action_map.has_key(items[0]):
	    return self._item_to_action_map[items[0]]

    def action_added(self, action):
	"Callback from ActionManager. Adds an Icon for the new Action"
	icon = Icon(self, action)
	self._item_to_action_map[icon.img] = action
	self._action_to_icon_map[action] = icon
	self.update()

    def action_moved(self, action):
	"Callback from ActionManager. Moves the Icon to follow the Action"
	icon = self._action_to_icon_map[action]
	icon.update_pos()
	self.update()


class CanvasView (QCanvasView):
    def __init__(self, canvas, parent):
	QCanvasView.__init__(self, canvas, parent)
	self.actions = parent.actions
	self.window = parent
	self.__canvas = canvas
	self.__strategies = {
	    'select' : SelectionStrategy(canvas, self),
	    'connect': ConnectStrategy(canvas, self),
	    'action' : AddActionStrategy(canvas, self)
	}
	
	self.__strategy = self.__strategies['select']
	self.connect(parent, PYSIGNAL('modeChanged(string)'), self.modeChanged)
    def modeChanged(self, tool):
	if self.__strategies.has_key(tool):
	    self.__strategy.reset()
	    self.__strategy = self.__strategies[tool]
	    self.__strategy.set()
    def contentsMousePressEvent(self, event):
	self.__strategy.press(event)
    def contentsMouseReleaseEvent(self, event):
	self.__strategy.release(event)
    def contentsMouseMoveEvent(self, event):
	self.__strategy.move(event)
	

class CanvasWindow (QVBox):
    def __init__(self, parent, main_window):
	QVBox.__init__(self, parent)
	self.setCaption("Canvas")
	self.main_window = main_window
	self.__activated = 0

	# Make the menu, to be inserted in the app menu upon window activation
	self._file_menu = QPopupMenu(main_window.menuBar())
	self._file_menu.insertItem("New &Action", self.addAction, Qt.CTRL+Qt.Key_A)

	# Make the toolbar
	self.tool = QToolBar("Canvas", self.main_window, self)
	pixmap = QPixmap(16,16); pixmap.fill()
	self.tool_sel = QToolButton(pixmap, "Select", "Select actions in the display", self.setSelect, self.tool)
	self.tool_sel.setToggleButton(1)

	pixmap = QPixmap(16,16); pixmap.fill(Qt.red)
	self.tool_con = QToolButton(pixmap, "Connect", "Connect two actions", self.setConnect, self.tool)
	self.tool_con.setToggleButton(1)

	pixmap = QPixmap(16,16); pixmap.fill(Qt.blue)
	self.tool_add = QToolButton(pixmap, "Add Action", "Add a new action to the project", self.setAction, self.tool)
	self.tool_add.setToggleButton(1)

	self.__tools = {
	    'select' : self.tool_sel,
	    'connect': self.tool_con,
	    'action' : self.tool_add
	}
	# Make the canvas
	self.actions = ActionManager()
	self.canvas = ActionCanvas(self.actions, self)
	self.canvas.resize(parent.width(), parent.height())
	CanvasView(self.canvas, self)
	self.show()

	self.connect(parent, SIGNAL('windowActivated(QWidget*)'), self.windowActivated)

	self.setMode('select')
	self.activate()
	
    def setMode(self, mode):
	self.mode = mode
	tool = self.__tools[mode]
	for other in self.__tools.values():
	    if tool is not other:
		other.setOn(0)
	tool.setOn(1)

	self.emit(PYSIGNAL('modeChanged(string)'), (self.mode,))

    def windowActivated(self, widget):
	if self.__activated:
	    if widget is not self:
		self.deactivate()
	else:
	    if widget is self:
		self.activate()
    
    def activate(self):
	self.__activated = 1
	self._menu_id = self.main_window.menuBar().insertItem('Canvas', self._file_menu)

    def deactivate(self):
	self.__activated = 0
	self.main_window.menuBar().removeItem(self._menu_id)

    def addAction(self):
	self.actions.add_action(Action(10, 10, "hello"))

    def setSelect(self):
	self.setMode('select')

    def setConnect(self):
	self.setMode('connect')

    def setAction(self):
	self.setMode('action')

class Icon:
    def __init__(self, canvas, action):
	self.action = action
	self.canvas = canvas
	self.img = QCanvasRectangle(action.x(), action.y(), 32, 32, canvas)
	self.text = QCanvasText(action.name(), canvas)
	self.img.show()
	self.text.show()
	self.update_pos()
    def update_pos(self):
	self.img.move(self.action.x(), self.action.y())
	rect = self.text.boundingRect()
	irect = self.img.boundingRect()
	y = irect.bottom()
	x = irect.center().x() - rect.width()/2
	self.text.move(x, y)

class MainWindow (QMainWindow):
    """The main window of the applet. It controls the whole GUI so far, and
    has two ListFillers, one for each QListView."""
    def __init__(self):
	QMainWindow.__init__(self, None, "Synopsis")

	# Make the menu
	menu = self.menuBar()
	file = QPopupMenu(self)
	file.insertItem("&Open...", self.open, Qt.CTRL+Qt.Key_O)
	file.insertItem("&Canvas", self.openCanvas, Qt.CTRL+Qt.Key_C)
	file.insertItem("&Quit", qApp, SLOT( "quit()" ), Qt.CTRL+Qt.Key_Q )
	menu.insertItem("&File", file)

	self.workspace = QWorkspace(self)
	self.setCentralWidget(self.workspace)

    def open(self):
	"""Displays the file open dialog, and loads a file if selected"""
	file = QFileDialog.getOpenFileName(".", "Synopsis files (*.*syn)", self, "file", "Open a Synopsis data file")
	if file: self.openFile(str(file))


    def openFile(self, filename):
	"""Loads a given file"""
	try:
	    unpickler = pickle.Unpickler(open(filename, "r"))
	    # Load the file
	    version = unpickler.load()
	    ast = unpickler.load()
	    # Fill the GUI
	    glob = AST.Scope('', -1, '', 'Global', ('global',))
	    glob.declarations().extend(ast.declarations())
	    win = BrowseWindow(self.workspace, filename, glob)
	    win.show()
	except IOError, e:
	    # Oops..
	    QMessageBox.critical(self, "Synopsis", 
		"An error occurred opening:\n%s\n\n%s"%(filename, str(e)))
    
    def openCanvas(self):
	CanvasWindow(self.workspace, self).show()

class ListFiller( AST.Visitor ):
    """A visitor that fills in a QListView from an AST"""
    def __init__(self, main, listview, types = None):
	self.map = {}
	self.main = main
	self.listview = listview
	self.stack = [self.listview]
	self.types = types
	self.auto_open = 1

    def clear(self):
	self.listview.clear()
	self.map = {}
	self.stack = [self.listview]

    def fillFrom(self, decl):
	self.visitGroup(decl)
	self.listview.setContentsPos(0,0)

    def visitDeclaration(self, decl):
	if self.types and decl.type() not in self.types: return
	item = QListViewItem(self.stack[-1], decl.name()[-1], decl.type())
	self.map[item] = decl
	self.__last = item

    def visitGroup(self, group):
	if self.types and group.type() not in self.types: return
	self.visitDeclaration(group)
	item = self.__last
	self.stack.append(item)
	for decl in group.declarations(): decl.accept(self)
	self.stack.pop()
	if len(self.stack) <= self.auto_open: self.listview.setOpen(item, 1)

    def visitForward(self, fwd): pass

    def visitEnum(self, enum):
	if self.types and enum.type() not in self.types: return
	self.visitDeclaration(enum)
	item = self.__last
	self.stack.append(item)
	for decl in enum.enumerators(): decl.accept(self)
	self.stack.pop()
	if len(self.stack) <= self.auto_open: self.listview.setOpen(item, 1)


if __name__ == "__main__":
    # This is usually set in ASCII's parse_args function.. but we can set it to
    # something more appropriate
    Synopsis.Formatter.ASCII.comment_str = '<font color="purple">// %s</font>\n'

    app = QApplication(sys.argv)
    #app.setDesktopSettingsAware(1) # doesnt work with Qt 2
    # So I prefer the windows style to motif.. shoot me :)
    app.setStyle(QWindowsStyle())
    #app.setStyle(QPlatinumStyle())

    # Parse args
    load_file = None
    for arg in sys.argv[1:]:
	if arg and arg[0] != '-':
	    load_file = arg

    # Load files
    ast = None
    main = MainWindow()
    app.setMainWidget(main)
    main.show()

    if load_file:
	main.openFile(load_file)

    app.exec_loop()

