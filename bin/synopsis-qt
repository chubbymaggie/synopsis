#!/usr/bin/env python
# Qt GUI for Synopsis
# Copyright (c) 2001 by Stephen Davies
#
# Tested on Debian unstable with python-pyqt package (and dependencies)
# This appears to be using Qt 2.0


import sys, pickle, Synopsis, cStringIO
from qt import *
from Synopsis.Core import AST, Util
from Synopsis.Formatter.ASCII import ASCIIFormatter
from Synopsis.Formatter.ClassTree import ClassTree


class BrowseWindow (QSplitter):
    """A window that browses a given .syn file"""
    def __init__(self, parent, main_window, filename, global_decl):
	QSplitter.__init__(self, parent)
	self.filename = filename
	self.global_decl = global_decl
	self.main_window = main_window

	self.setCaption("'%s' - Browse"%filename)

	# Split up the GUI
	splitV = QSplitter(Qt.Vertical, self)

	# Create a top-left listview for the packages
	self.packages = QListView(splitV)
	self.packages.setMinimumSize(150,100)
	self.packages.addColumn("Name")

	# Create a bottom-left listview for the other stuff
	self.listview = QListView(splitV)
	self.listview.setMinimumSize(150,300)
	self.listview.addColumn("Name")
	self.listview.addColumn("Type")

	# Create a textbrowser to show info about selected stuff
	# This could be just QTextEdit or something I guess... :)
	self.textview = QTextBrowser(self)
	self.textview.setMinimumSize(500,350)
	self.textview.setTextFormat(Qt.RichText)


	# Create the fillers. The first only displays a few types
	self.packfiller = ListFiller(self, self.packages, (
	    'Package', 'Module', 'Namespace', 'Global'))
	self.packfiller.auto_open = 3
	self.listfiller = ListFiller(self, self.listview)

	# Connect things up
	self.connect(self.packages, SIGNAL('selectionChanged(QListViewItem*)'), self.showPackage)
	self.connect(self.listview, SIGNAL('selectionChanged(QListViewItem*)'), self.showDecl)
	self.connect(self.listview, SIGNAL('expanded(QListViewItem*)'), self.selfishExpansion)

	self.textview.setText("<i>Select a package/namespace to view from the left.")
	self.packfiller.fillFrom(global_decl)

	# Make the menu, to be inserted in the app menu upon window activation
	self._file_menu = QPopupMenu(self.main_window.menuBar())
	self._graph_id = self._file_menu.insertItem("&Graph class inheritance", self.openGraph, Qt.CTRL+Qt.Key_G)

	self.__activated = 0
	self.connect(parent, SIGNAL('windowActivated(QWidget*)'), self.windowActivated)
	self.show()

	self.classTree = ClassTree()
	self.global_decl.accept(self.classTree)

    def windowActivated(self, widget):
	if self.__activated:
	    if widget is not self: self.deactivate()
	elif widget is self: self.activate()
    
    def activate(self):
	self.__activated = 1
	self._menu_id = self.main_window.menuBar().insertItem('AST', self._file_menu)

    def deactivate(self):
	self.__activated = 0
	self.main_window.menuBar().removeItem(self._menu_id)


    def openGraph(self):
	# Find the right graph
	graphs = self.classTree.graphs()
	classes = None
	for graph in graphs:
	    if self.decl.name() in graph:
		classes = graph
		break
	if not classes:
	    print "Warning: unable to find class",self.decl.name(),"in any graph"
	    print graphs
	    return
	IGraphWindow(self.main_window, self.decl, classes, self.classTree)

    def setGraphEnabled(self, enable):
	self._file_menu.setItemEnabled(self._graph_id, enable)

    def showPackage(self, item):
	"""Show a given package (by item)"""
	decl = self.packfiller.map[item]
	self.setGraphEnabled(0)
	# Fill the main list
	self.listfiller.clear()
	self.listfiller.fillFrom(decl)
	# Grab the comments and put them in the text view
	os = cStringIO.StringIO()
	for comment in decl.comments():
	    os.write(comment.text())
	    os.write('<hr>')
	self.textview.setText(os.getvalue())

    def showDecl(self, item):
	"""Show a given declaration (by item)"""
	decl = self.listfiller.map[item]
	self.decl = decl
	self.setGraphEnabled(isinstance(decl, AST.Class))
	# Here we use ASCIIFormatter to quickly get us *something* to display
	# :)
	os = cStringIO.StringIO()
	os.write('<pre>')
	formatter = ASCIIFormatter(os)
	formatter.set_scope(decl.name())
	decl.accept(formatter)
	self.textview.setText(os.getvalue())

    def selfishExpansion(self, item):
	"""Selfishly makes item the only expanded node"""
	if not item.parent(): return
	iter = item.parent().firstChild()
	while iter:
	    if iter != item: self.listview.setOpen(iter, 0)
	    iter = iter.nextSibling()

class IGraphWindow (QCanvasView):
    class Icon:
	def __init__(self, canvas, classname, x, y):
	    self.classname = classname
	    name = Util.ccolonName(classname[-1:])
	    self.text = QCanvasText(name, canvas)
	    self.text.setZ(2)
	    self.text.show()
	    r = self.text.boundingRect()
	    self.border = QCanvasRectangle(x , y, r.width()+4,r.height()+4, canvas)
	    self.border.setBrush(QBrush(QColor(255,255,200)))
	    self.border.setZ(1)
	    self.border.show()
	    self.subs = []
	    self.supers = []
	    self.sub_lines = []
	    self.super_lines = []
	    self.move_to(x, y)
	def move_to(self, x, y):
	    self.x = x
	    self.y = y
	    self.border.move(x, y)
	    self.text.move(x+2,y+2)
	    r = self.border.boundingRect()
	    self.mid_x = (r.left() + r.right())/2
	    self.max_x = r.right()
	    self.top_y = r.top()
	    self.mid_y = (r.top() + r.bottom())/2
	    self.max_y = r.bottom()
	    for sub in self.sub_lines: self.move_sub(sub)
	    for super in self.super_lines: self.move_super(super)
	def width(self):
	    "returns the width of this icon"
	    return self.border.boundingRect().width()
	def mid(self):
	    "Returns the x, y coords of the middle of this icon"
	    return self.mid_x, self.mid_y
	def add_sub(self, sub, line):
	    self.subs.append(sub)
	    self.sub_lines.append(line)
	    self.move_sub(line)
	def move_sub(self, line):
	    other = line.endPoint()
	    line.setPoints(self.mid_x, self.mid_y, other.x(), other.y())
	def add_super(self, super, line):
	    self.supers.append(super)
	    self.super_lines.append(line)
	    self.move_super(line)
	def move_super(self, line):
	    other = line.startPoint()
	    line.setPoints(other.x(), other.y(), self.mid_x, self.top_y)


    def __init__(self, main_window, start_class, classes, classTree):
	self.__canvas = QCanvas()
	self.main_window = main_window
	self.classes = classes
	self.classTree = classTree
	parent = main_window.workspace
	QCanvasView.__init__(self, self.__canvas, parent)
	self.canvas().resize(parent.width(), parent.height())

	# First create all icons
	self.icons = {}
	for clas in classes:
	    self.icons[clas]= self.Icon(self.__canvas, clas, 0,0)

	# Now connect their supers and subs lists
	for name, icon in self.icons.items():
	    for child in self.classTree.subclasses(name):
		line = QCanvasLine(self.__canvas)
		sub = self.icons[child]
		icon.add_sub(sub, line)
		sub.add_super(icon, line)
		line.show()
	
	self.organize()

	self.show()

    def organize(self):
	# find a root
	roots = filter(lambda x: not x.supers, self.icons.values())
	if not roots: return # this is an error
	root = roots[0]
	self._organized = {}
	self._ranks = {}
	self.rank_down(root)
	self.sort_ranks()

	self.un_offset()

    def un_offset(self):
	"""Moves the graph to the top-left corner of the display"""
	# Find top-left of graph
	min_x, min_y = 0, 0
	for node in self.icons.values():
	    if node.x < min_x: min_x = node.x
	    if node.y < min_y: min_y = node.y
	# Move to top-left of display
	min_x, min_y = min_x - 10, min_y - 10
	max_x, max_y = 0, 0
	for node in self.icons.values():
	    node.move_to(node.x - min_x, node.y - min_y)
	    if node.max_x > max_x: max_x = node.max_x
	    if node.max_y > max_y: max_y = node.max_y
	self.__canvas.resize(max_x+10, max_y+10)

    def rank_down(self, node):
	self._organized[node] = None
	if not self._ranks.has_key(node.y): self._ranks[node.y] = []
	self._ranks[node.y].append(node)
	min_y = node.y + 30
	for sub in node.subs:
	    if self._organized.has_key(sub) and min_y < sub.y: continue
	    sub.move_to(sub.x, node.y + 30)
	    self.rank_down(sub)

	for super in node.supers:
	    if self._organized.has_key(super): continue
	    super.move_to(super.x, node.y - 30)
	    self.rank_down(super)
    
    def sort_ranks(self):
	ranks = self._ranks.keys()
	ranks.sort()
	for rank in ranks:
	    nodes = self._ranks[rank]
	    done = {}
	    order = []
	    rank_x = -1e6
	    for node in nodes:
		for super in node.supers:
		    set = filter(lambda n, y=rank: n.y==y, super.subs)
		    set = filter(lambda n, d=done: not d.has_key(n), set)
		    order.extend(set)
		    for s in set: done[s] = 1
		    set_width = 0
		    for s in set: set_width = set_width + s.width() + 2
		    # Move nodes to their new order
		    x = super.mid()[0] - set_width/2
		    if x < rank_x: x = rank_x
		    for s in set:
			s.move_to(x, s.y)
			x = x + s.width() + 2
		    rank_x = x + 2
		if not node.supers:
		    # Backup: no siblings to rank with so just use rank_x
		    if rank_x < -1e5: rank_x = 0
		    node.move_to(rank_x, node.y)
		    rank_x = rank_x + node.width() + 2
		    order.append(node)
		    done[node] = 1
	    #print rank, map(lambda n:'%s:%d'%(n.classname[-1],n.x), order)

		    

	

class Action:
    """A Synopsis Action, ie: parsing, linking, formatting etc"""
    def __init__(self, x, y, name):
	self.__x = x
	self.__y = y
	self.__name = name
	self.__inputs = []
	self.__outputs = []
    
    def x(self): return self.__x
    def y(self): return self.__y
    def pos(self): return self.__x, self.__y
    def move_to(self, x, y): self.__x = x; self.__y = y
    def move_by(self, dx, dy): self.__x = self.__x+dx; self.__y = self.__y+dy
    def name(self): return self.__name
    def set_name(self, name): self.__name = name
    def inputs(self): return self.__inputs
    def outputs(self): return self.__outputs
    def accept(self, visitor): visitor.visitAction(self)

class ActionVisitor:
    def visitAction(self, action): pass
    def visitSource(self, action): pass
    def visitParser(self, action): pass
    def visitLinker(self, action): pass
    def visitCacher(self, action): pass
    def visitFormat(self, action): pass

class SourceAction (Action):
    """A Synopsis Action that loads source files"""
    def __init__(self, x, y=0, name=""):
	if isinstance(x, Action): Action.__init__(self, x.x(), x.y(), x.name())
	else: Action.__init__(self, x, y, name)
    def accept(self, visitor): visitor.visitSource(self)

class ParserAction (Action):
    """A Synopsis Action that parses source files"""
    def __init__(self, x, y=0, name=""):
	if isinstance(x, Action): Action.__init__(self, x.x(), x.y(), x.name())
	else: Action.__init__(self, x, y, name)
    def accept(self, visitor): visitor.visitParser(self)

class LinkerAction (Action):
    """A Synopsis Action that links ASTs"""
    def __init__(self, x, y=0, name=""):
	if isinstance(x, Action): Action.__init__(self, x.x(), x.y(), x.name())
	else: Action.__init__(self, x, y, name)
    def accept(self, visitor): visitor.visitLinker(self)

class CacherAction (Action):
    """A Synopsis Action that caches ASTs to disk"""
    def __init__(self, x, y=0, name=""):
	if isinstance(x, Action): Action.__init__(self, x.x(), x.y(), x.name())
	else: Action.__init__(self, x, y, name)
    def accept(self, visitor): visitor.visitCacher(self)

class FormatAction (Action):
    """A Synopsis Action that formats ASTs"""
    def __init__(self, x, y=0, name=""):
	if isinstance(x, Action): Action.__init__(self, x.x(), x.y(), x.name())
	else: Action.__init__(self, x, y, name)
    def accept(self, visitor): visitor.visitFormat(self)

class ActionManager:
    """Manages the actions in a project"""
    class Listener:
	def action_added(self, action): pass
	def action_moved(self, action): pass
    def __init__(self):
	self.__actions = []
	self.__listeners = []
    def add_listener(self, l):
	self.__listeners.append(l)
    def fire(self, signal, *args):
	for l in self.__listeners:
	    if hasattr(l, signal):
		apply(getattr(l, signal), args)
    def add_action(self, action):
	self.__actions.append(action)
	self.fire('action_added', action)
    def move_action(self, action, x, y):
	action.move_to(x, y)
	self.fire('action_moved', action)
    def move_action_by(self, action, dx, dy):
	action.move_by(dx, dy)
	self.fire('action_moved', action)
    def remove_action(self, action):
	self.__actions.remove(action)
	self.fire('action_removed', action)
    def add_channel(self, source, dest):
	source.outputs().append(dest)
	dest.inputs().append(source)
	self.fire('channel_added', source, dest)

class CanvasStrategy:
    "An interface for a strategy to handle mouse events"
    def __init__(self, canvas, view):
	self.canvas = canvas
	self.view = view
    def reset(self): pass
    def set(self): pass
    def press(self, event): pass
    def release(self, event): pass
    def move(self, event): pass
    def key(self, event):
	if event.key() == Qt.Key_Escape:
	    self.view.window.setMode('select')
	else:
	    event.ignore()

class SelectionStrategy (CanvasStrategy):
    def __init__(self, canvas, view):
	CanvasStrategy.__init__(self, canvas, view)
	self.__drag_action = None
	self.__icon = None
	self.__last = None
	self.__normal_cursor = QCursor(ArrowCursor)
	self.__moving_cursor = QCursor(BlankCursor)
	self.__hint_cursor = QCursor(SizeAllCursor)

    def reset(self):
	self.__drag_item = None

    def press(self, event):
	action = self.canvas.get_action_at(event.x(), event.y())
	if action:
	    self.__drag_action = action
	    self.__last = QPoint(event.pos())
	    self.view.setCursor(self.__moving_cursor)
	    
    def release(self, event):
	if self.__drag_action:
	    self.__drag_action = None
	    self.view.setCursor(self.__hint_cursor)
	    
    def move(self, event):
	if self.__drag_action:
	    # Move the dragging action
	    dx = event.x() - self.__last.x()
	    dy = event.y() - self.__last.y()
	    self.view.actions.move_action_by(self.__drag_action, dx, dy)
	    self.__last = QPoint(event.pos())
	else:
	    if self.canvas.get_action_at(event.x(), event.y()):
		self.view.setCursor(self.__hint_cursor)
	    else:
		self.view.setCursor(self.__normal_cursor)
    
    def key(self, event):
	"Override default set-mode-to-select behaviour"
	event.ignore()

class ConnectStrategy (CanvasStrategy):
    def __init__(self, canvas, view):
	CanvasStrategy.__init__(self, canvas, view)
	self.__normal_cursor = QCursor(ArrowCursor)
	self.__hint_cursor = QCursor(UpArrowCursor)
	self.__find_cursor = QCursor(SizeHorCursor)
	self.templine = QCanvasLine(self.canvas)
	self.templine.setPen(QPen(Qt.blue, 1, Qt.DotLine))

    def set(self):
	self.source = None
	self.templine.hide()
	self.canvas.update()
    def reset(self):
	self.templine.hide()
	self.canvas.update()
    def move(self, event):
	if self.source:
	    self.templine.setPoints(self.source.x()+16, self.source.y()+16, event.x(), event.y())
	    self.canvas.update()
	action = self.canvas.get_action_at(event.x(), event.y())
	if action and action is not self.source:
	    self.view.setCursor(self.__hint_cursor)
	elif self.source:
	    self.view.setCursor(self.__find_cursor)
	else:
	    self.view.setCursor(self.__normal_cursor)
    def press(self, event):
	action = self.canvas.get_action_at(event.x(), event.y())
	if not action: return
	if not self.source: self.setSource(action, event)
	elif action is not self.source: self.setDest(action)
    def release(self, event):
	action = self.canvas.get_action_at(event.x(), event.y())
	if action and self.source and action is not self.source: self.setDest(action)
    def setSource(self, action, event):
	self.source = action
	self.templine.setPoints(action.x()+16, action.y()+16, event.x(), event.y())
	self.templine.show()
	self.canvas.update()
    def setDest(self, action):
	self.templine.hide()
	self.view.actions.add_channel(self.source, action)
	self.source = None
	self.view.window.setMode('select')

class AddActionStrategy (CanvasStrategy):
    def __init__(self, canvas, view):
	CanvasStrategy.__init__(self, canvas, view)
	self.__drag_action = None
	self.__normal_cursor = QCursor(ArrowCursor)
	self.__moving_cursor = QCursor(BlankCursor)

    def set(self):
	self.action = Action(self.view.last_pos.x()-16,
			     self.view.last_pos.y()-16, "new action")
	self.view.actions.add_action(self.action)
	self.view.setCursor(self.__moving_cursor)

    def reset(self):
	if self.action:
	    self.view.actions.remove_action(self.action)
	self.view.setCursor(self.__normal_cursor)

    def move(self, event):
	self.view.actions.move_action(self.action, event.x()-16, event.y()-16)

    def release(self, event):
	wizard = AddWizard(self.view, self.action)
	if wizard.exec_loop() == QDialog.Rejected:
	    self.view.actions.remove_action(self.action)
	if wizard.action is not self.action:
	    # Wizard may create a new more derived action object
	    self.view.actions.remove_action(self.action)
	    self.view.actions.add_action(wizard.action)
	self.action = None
	self.view.window.setMode('select')

class AddWizard (QWizard):
    def __init__(self, parent, action):
	QWizard.__init__(self, parent, 'AddWizard', 1)
	self.action = action

	self.title_font = QFont('Helvetica', 20, QFont.Bold)
	self.title_palette = QPalette(self.palette())
	self.title_palette.setColor(QPalette.Normal, QColorGroup.Foreground, Qt.white)
	self.title_palette.setColor(QPalette.Normal, QColorGroup.Background, Qt.darkBlue)
	self.title_label = QLabel('', self)
	self.title_label.setFrameStyle(QFrame.Panel | QFrame.Sunken)
	self.title_label.setLineWidth(1)
	self.title_label.setMidLineWidth(1)
	self.title_label.setPalette(self.title_palette)
	self.title_label.setFont(self.title_font)

	self._makeStartPage()
	self._makeSourcePage()
	self._makeFinishPage()

    def _makeStartPage(self):
	vbox = QVBox(self)
	vbox.layout().setSpacing(4)
	QLabel('What type of action would you like to create?', vbox)
	group = QButtonGroup(1, Qt.Horizontal, "&Action type", vbox)
	radio_source = QRadioButton('&Source - Specifies, monitors and loads source code files', group)
	radio_parser = QRadioButton('&Parser - Reads source files and parses them into ASTs', group)
	radio_linker = QRadioButton('&Linker - Operates on one or more ASTs, typically linking various things together', group)
	radio_cacher = QRadioButton('File &Cache - Stores an AST to disk to speed reprocessing', group)
	radio_format = QRadioButton('&Formatter - Exports an AST to some format, eg: HTML, PDF', group)
	self.__action_type_group = group
	self.__action_types = {
	    radio_source: 'source', radio_parser: 'parser', radio_linker: 'linker',
	    radio_format: 'format', radio_cacher: 'cacher' }
	self.connect(group, SIGNAL('clicked(int)'), self.onActionType)

	self.addPage(vbox, "Select action type")
	self.setNextEnabled(vbox, 0)
	self.setHelpEnabled(vbox, 0)
	self.start = vbox

    def onActionType(self, id):
	t = self.__action_types[self.__action_type_group.find(id)]
	if t == 'source':
	    self.action = SourceAction(self.action)
	    self.action.set_name('New source action')
	    self.setAppropriate(self.source, 1)
	elif t == 'parser':
	    self.action = ParserAction(self.action)
	elif t == 'linker':
	    self.action = LinkerAction(self.action)
	elif t == 'cacher':
	    self.action = CacherAction(self.action)
	elif t == 'format':
	    self.action = FormatAction(self.action)
	self.nextButton().setEnabled(1)

    def _makeSourcePage(self):
	vbox = QVBox(self)
	QLabel("Source actions are responsible for knowing what files to load\n"+
	       "from disk for parsing. They watch specified directories for new\n"+
	       "files that match the extensions they are looking for.", vbox)
	hbox = QHBox(vbox)
	label = QLabel("Action &name:", hbox)
	self.source_name = QLineEdit(hbox)
	label.setBuddy(self.source_name)
	self.connect(self.source_name, SIGNAL('textChanged(const QString&)'), self.onActionName)

	self.addPage(vbox, "Source action config")
	self.setHelpEnabled(vbox, 0)
	self.setAppropriate(vbox, 0)
	self.source = vbox

    def onActionName(self, name):
	self.action.set_name(name)

    def _makeFinishPage(self):
	vbox = QVBox(self)
	QLabel('You have finished creating your new action.', vbox)
	self.addPage(vbox, "Finished")
	self.setFinish(vbox, 1)
	self.setFinishEnabled(vbox, 1)
	self.setHelpEnabled(vbox, 0)
	self.finish = vbox

    def showPage(self, page):
	if page is self.source:
	    self.source_name.setText(self.action.name())
	QWizard.showPage(self, page)

	if page is self.source:
	    self.source_name.setFocus()
	    self.source_name.selectAll()
	if page is self.finish:
	    self.finishButton().setFocus()

    def layOutTitleRow(self, hbox, title):
	self.title_label.setText(title)
	hbox.add(self.title_label)
	

class ActionColorizer (ActionVisitor):
    def __init__(self, action=None):
	self.color = None
	if action: action.accept(self)
    def visitAction(self, action): self.color=Qt.black
    def visitSource(self, action): self.color=Qt.magenta
    def visitParser(self, action): self.color=Qt.red
    def visitLinker(self, action): self.color=Qt.yellow
    def visitCacher(self, action): self.color=Qt.green
    def visitFormat(self, action): self.color=Qt.cyan

class Icon:
    "Encapsulates the canvas display of an Action"

    def __init__(self, canvas, action):
	self.action = action
	self.canvas = canvas
	self.img = QCanvasRectangle(action.x(), action.y(), 32, 32, canvas)
	self.img.setBrush(QBrush(ActionColorizer(action).color))
	self.img.setZ(1)
	self.text = QCanvasText(action.name(), canvas)
	self.text.setZ(1)
	self.img.show()
	self.text.show()
	self.update_pos()
    def update_pos(self):
	self.img.move(self.action.x(), self.action.y())
	rect = self.text.boundingRect()
	irect = self.img.boundingRect()
	y = irect.bottom()
	x = irect.center().x() - rect.width()/2
	self.text.move(x, y)

class Line:
    "Encapsulates the canvas display of a channel between two Actions"
    def __init__(self, canvas, source, dest):
	self.canvas = canvas
	self.source = source
	self.dest = dest
	self.line = QCanvasLine(canvas)
	self.line.setPen(QPen(Qt.blue))
	self.update_pos()
	self.line.show()
    def update_pos(self):
	source, dest = self.source, self.dest
	self.line.setPoints(
	    source.x()+16, source.y()+16,
	    dest.x()+16, dest.y()+16)


class ActionCanvas (QCanvas):
    """Extends QCanvas to automatically fill and update the canvas when
    notified of events by an ActionManager"""
    def __init__(self, actions, parent):
	QCanvas.__init__(self, parent)
	self.actions = actions
	self._item_to_action_map = {}
	self._action_to_icon_map = {}
	self._action_lines = {}

	self.actions.add_listener(self)

    def get_action_at(self, x, y):
	"Returns the Action (if any) at the given coordinates"
	items = self.collisions(QPoint(x, y))
	if items and self._item_to_action_map.has_key(items[0]):
	    return self._item_to_action_map[items[0]]

    def action_added(self, action):
	"Callback from ActionManager. Adds an Icon for the new Action"
	icon = Icon(self, action)
	self._item_to_action_map[icon.img] = action
	self._action_to_icon_map[action] = icon
	self.update()

    def action_removed(self, action):
	"Callback from ActionManager. Removes the Icon for the Action"
	icon = self._action_to_icon_map[action]
	del self._action_to_icon_map[action]
	del self._item_to_action_map[icon.img]

    def action_moved(self, action):
	"Callback from ActionManager. Moves the Icon to follow the Action"
	icon = self._action_to_icon_map[action]
	icon.update_pos()
	if self._action_lines.has_key(action):
	    for line in self._action_lines[action]:
		line.update_pos()
	self.update()

    def channel_added(self, source, dest):
	"Callback from ActionManager. Adds a channel between the given actions"
	line = Line(self, source, dest)
	if not self._action_lines.has_key(source):
	    self._action_lines[source] = []
	if not self._action_lines.has_key(dest):
	    self._action_lines[dest] = []
	self._action_lines[source].append(line)
	self._action_lines[dest].append(line)
	self.update()


class CanvasView (QCanvasView):
    def __init__(self, canvas, parent):
	QCanvasView.__init__(self, canvas, parent)
	self.actions = parent.actions
	self.window = parent
	self.last_pos = QPoint(-50,-50)
	self.viewport().setFocusPolicy(QWidget.ClickFocus)
	self.__canvas = canvas
	self.__strategies = {
	    'select' : SelectionStrategy(canvas, self),
	    'connect': ConnectStrategy(canvas, self),
	    'action' : AddActionStrategy(canvas, self)
	}
	self.viewport().setMouseTracking(1)
	
	self.__strategy = self.__strategies['select']
	self.connect(parent, PYSIGNAL('modeChanged(string)'), self.modeChanged)
    def modeChanged(self, tool):
	if self.__strategies.has_key(tool):
	    self.__strategy.reset()
	    self.__strategy = self.__strategies[tool]
	    self.__strategy.set()
    def contentsMousePressEvent(self, event):
	self.__strategy.press(event)
    def contentsMouseReleaseEvent(self, event):
	self.__strategy.release(event)
    def contentsMouseMoveEvent(self, event):
	self.last_pos = QPoint(event.pos())
	self.__strategy.move(event)
    def keyPressEvent(self, event):
	self.__strategy.key(event)
	

class CanvasWindow (QVBox):
    def __init__(self, parent, main_window):
	QVBox.__init__(self, parent)
	self.setCaption("Canvas")
	self.main_window = main_window
	self.__activated = 0

	# Make the toolbar
	self.buttons = QButtonGroup()
	self.buttons.setExclusive(1)
	self.tool = QToolBar("Canvas", self.main_window, self)
	self.tool.setHorizontalStretchable(0)
	pixmap = QPixmap(16,16); pixmap.fill()
	self.tool_sel = QToolButton(pixmap, "Select", "Select actions in the display", self.setSelect, self.tool)
	self.tool_sel.setUsesTextLabel(1)
	self.tool_sel.setToggleButton(1)
	self.buttons.insert(self.tool_sel)

	pixmap = QPixmap(16,16); pixmap.fill(Qt.blue)
	self.tool_con = QToolButton(pixmap, "Connect", "Connect two actions", self.setConnect, self.tool)
	self.tool_con.setUsesTextLabel(1)
	self.tool_con.setToggleButton(1)
	self.buttons.insert(self.tool_con)

	pixmap = QPixmap(16,16); pixmap.fill(Qt.red)
	self.tool_add = QToolButton(pixmap, "Add Action", "Add a new action to the project", self.setAction, self.tool)
	self.tool_add.setUsesTextLabel(1)
	self.tool_add.setToggleButton(1)
	self.buttons.insert(self.tool_add)

	# Make the menu, to be inserted in the app menu upon window activation
	self._file_menu = QPopupMenu(main_window.menuBar())
	self._file_menu.insertItem("New &Action", self.setAction, Qt.CTRL+Qt.Key_A)


	self.__tools = {
	    'select' : self.tool_sel,
	    'connect': self.tool_con,
	    'action' : self.tool_add
	}
	# Make the canvas
	self.actions = ActionManager()
	self.canvas = ActionCanvas(self.actions, self)
	self.canvas.resize(parent.width(), parent.height())
	CanvasView(self.canvas, self)
	self.show()

	self.connect(parent, SIGNAL('windowActivated(QWidget*)'), self.windowActivated)

	self.setMode('select')
	self.activate()
	
    def setMode(self, mode):
	self.mode = mode
	self.__tools[mode].setOn(1)

	self.emit(PYSIGNAL('modeChanged(string)'), (self.mode,))

    def windowActivated(self, widget):
	if self.__activated:
	    if widget is not self: self.deactivate()
	elif widget is self: self.activate()
    
    def activate(self):
	self.__activated = 1
	self._menu_id = self.main_window.menuBar().insertItem('Canvas', self._file_menu)

    def deactivate(self):
	self.__activated = 0
	self.main_window.menuBar().removeItem(self._menu_id)

    def setSelect(self):
	self.setMode('select')

    def setConnect(self):
	self.setMode('connect')

    def setAction(self):
	self.setMode('action')

class MainWindow (QMainWindow):
    """The main window of the applet. It controls the whole GUI so far, and
    has two ListFillers, one for each QListView."""
    def __init__(self):
	QMainWindow.__init__(self, None, "Synopsis")

	# Make the menu
	menu = self.menuBar()
	file = QPopupMenu(self)
	file.insertItem("&Open...", self.open, Qt.CTRL+Qt.Key_O)
	file.insertItem("&Canvas", self.openCanvas, Qt.CTRL+Qt.Key_C)
	file.insertItem("&Quit", qApp, SLOT( "quit()" ), Qt.CTRL+Qt.Key_Q )
	menu.insertItem("&File", file)

	self.workspace = QWorkspace(self)
	self.setCentralWidget(self.workspace)

    def open(self):
	"""Displays the file open dialog, and loads a file if selected"""
	file = QFileDialog.getOpenFileName(".", "Synopsis files (*.*syn)", self, "file", "Open a Synopsis data file")
	if file: self.openFile(str(file))


    def openFile(self, filename):
	"""Loads a given file"""
	try:
	    unpickler = pickle.Unpickler(open(filename, "r"))
	    # Load the file
	    version = unpickler.load()
	    ast = unpickler.load()
	    # Fill the GUI
	    glob = AST.Scope('', -1, '', 'Global', ('global',))
	    glob.declarations().extend(ast.declarations())
	    win = BrowseWindow(self.workspace, self, filename, glob)
	    win.show()
	except IOError, e:
	    # Oops..
	    QMessageBox.critical(self, "Synopsis", 
		"An error occurred opening:\n%s\n\n%s"%(filename, str(e)))
    
    def openCanvas(self):
	CanvasWindow(self.workspace, self).show()

class ListFiller( AST.Visitor ):
    """A visitor that fills in a QListView from an AST"""
    def __init__(self, main, listview, types = None):
	self.map = {}
	self.main = main
	self.listview = listview
	self.stack = [self.listview]
	self.types = types
	self.auto_open = 1

    def clear(self):
	self.listview.clear()
	self.map = {}
	self.stack = [self.listview]

    def fillFrom(self, decl):
	self.visitGroup(decl)
	self.listview.setContentsPos(0,0)

    def visitDeclaration(self, decl):
	if self.types and decl.type() not in self.types: return
	item = QListViewItem(self.stack[-1], decl.name()[-1], decl.type())
	self.map[item] = decl
	self.__last = item

    def visitGroup(self, group):
	if self.types and group.type() not in self.types: return
	self.visitDeclaration(group)
	item = self.__last
	self.stack.append(item)
	for decl in group.declarations(): decl.accept(self)
	self.stack.pop()
	if len(self.stack) <= self.auto_open: self.listview.setOpen(item, 1)

    def visitForward(self, fwd): pass

    def visitEnum(self, enum):
	if self.types and enum.type() not in self.types: return
	self.visitDeclaration(enum)
	item = self.__last
	self.stack.append(item)
	for decl in enum.enumerators(): decl.accept(self)
	self.stack.pop()
	if len(self.stack) <= self.auto_open: self.listview.setOpen(item, 1)


if __name__ == "__main__":
    # This is usually set in ASCII's parse_args function.. but we can set it to
    # something more appropriate
    Synopsis.Formatter.ASCII.comment_str = '<font color="purple">// %s</font>\n'

    app = QApplication(sys.argv)
    #app.setDesktopSettingsAware(1) # doesnt work with Qt 2
    # So I prefer the windows style to motif.. shoot me :)
    app.setStyle(QWindowsStyle())
    #app.setStyle(QPlatinumStyle())
    app.setFont(QFont('Helvetica', 9))

    # Parse args
    load_file = None
    for arg in sys.argv[1:]:
	if arg and arg[0] != '-':
	    load_file = arg

    # Load files
    ast = None
    main = MainWindow()
    app.setMainWidget(main)
    main.show()

    if load_file:
	main.openFile(load_file)

    app.exec_loop()

