<chapter>
<title>Configuration</title>
  <para>Config file.. python script.. config.base.. examples/demos</para>
  <section>
    <title>Config Files</title>
    <para>
      There are two types of config file supported by Synopsis. The first
      was originally designed to be easy to read (both by the user and
      Synopsis), so it was made to be a Python script that followed certain
      conventions. It stores the configuration of multiple Parsers, Linkers
      and Formatters, and allows the configuration to be modified by command
      line arguments since each configuration is a class that is
      instantiated with options passed on the command line. The intended
      usage for this type of config file is to be repeatedly used for each
      stage of the process, driven by a Makefile integrated with the target
      project's build system. The basic format is:
    </para>
    <example>
      <title>An (incomplete) old config file</title>
      <programlisting>
# Import base config with default options
from Synopsis.Config import Base

# Derive our own config class
class Config (Base):
  # Make our own parser section
  class Parser:
    # Make a parser config called CXX, inheriting default options
    class CXX (Base.Parser.CXX):
      # Set an option
      main_only = 1
      # Write an init function that takes cmdline args
      def __init__(self, argv):
        # Deal with command line args
        if argv.has_key('verbose'): self.verbose = 1
    # Register all parser configs by name, in this case just one
    # called C++
    modules = { 'C++' : CXX }
  class Linker:
    # Similar to Parser
  class Formatter:
    # Similar to Parser, but here is part of a HTML config:
    class HTML (Base.Formatter.HTML):
      # Nested config for a HTML 'Page' called ScopePages:
      class ScopePages (Base.Formatter.HTML.ScopePages):
        # Extend the existing config option with two more 'formatters'
        # summary_formatters is a list of strings
        summary_formatters = \
          Base.Formatter.HTML.ScopePages.summary_formatters + \
          ['XRefLinker','SourceLinker']
    modules = { 'HTML' : HTML }
      </programlisting>
    </example>
    <para>
      The second type of config file is newer, and is designed to be read and
      written by the Synopsis GUI. It is still a Python script, but does
      away with the methods and nested classes, instead being one class
      called Project which has a number of attributes. Some of these
      attributes are quite complex, but are stored in a readable 'repr' type
      format. Configuration for modules is stored as an object instance
      internally rather than as a class, and is represented in the file as
      an object instantiation, like so:
    </para>
    <example><title>How object instantiation works</title>
      <programlisting>
# The 'struct' class is included at the top of the config file. It
# basically stores attributes given to the constructor
class struct:
  def __init__(self, **args):
    for key, value in args.items:
      setattr(self, key, value)
class Project:
  some_object = struct(
    name = "hi", 
    some_list = [1, 2, 3],
    nested_object = struct(
      type="foo",
      fred="baz"
    )
  )
      </programlisting>
    </example>
    <para>
      A full example is given at the end of this section.  The new Project
      structure defines not only configuration for the individual modules,
      but the relationships between different stages of the document
      generation process. The process is split into "Actions", each of which
      generally has inputs and outputs, with some exceptions:
    </para>
    <variablelist>
      <varlistentry>
        <term>SourceAction</term>
        <listitem><para>
          Selects the source files to use in the project.
          It has no input, and its output is just the names of the
          individual files. The SourceAction has a number of rules which it
          follows in turn to decide which files to use. The rules are set by
          the configuration, and can select simple file names, use recursive
          searches and glob expressions, or exclude previously selected
          files. The exclude is useful to not include temporary, backup, or
          cvs-related files in the documentation.
        </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>ParserAction</term>
        <listitem><para>
          Takes a list of files from one or more SourceActions at input, and
          applies a Parser to each one in turn. The output is a number of
          AST's, one for each input file. The ParserAction contains a config
          object with options for the parser.
        </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>CacherAction</term>
        <listitem><para>
          Can take as input any number of ASTs (from eg: ParserAction,
          LinkerAction). Outputs the same ASTs, but stores the ASTs on disk
          so that they don't need to be regenerated each time if the
          timestamps have not changed. There is a limitation in that the
          timestamps are only checked on the input source files themselves,
          not on their dependencies. This will be fixed in a later version.
        </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>LinkerAction</term>
        <listitem><para>
          Can take one or more ASTs as input, and outputs a single AST. The name
          comes from the process of linking a number of ASTs, typically from
          different source files, into a single cohesive AST. The Linker is
          more powerful than that however, allowing complex manipulations of
          the AST. These manipulations can be based on configuration only,
          or rely on comments extracted from the source files. The
          LinkerAction contains a config object to contain all the linker
          options available.
        </para></listitem>
      </varlistentry>
      <varlistentry>
        <term>FormatAction</term>
        <listitem><para>
          The FormatAction is the tail end of the chain, and takes a single
          AST which it converts into some output format. A number of output
          formats are supported, with varying degrees of completeness and
          usefulness. The HTML formatter is the most developed, having an
          immense range of configuration options.
        </para></listitem>
      </varlistentry>
    </variablelist>
    <para>
      The configuration options for the config objects in the Parser, Linker
      and Formatter objects are described later in this manual, and are the
      same as the old config format just with a different syntax.
    </para>
    <para>
      As mentioned, the main element of the config file is the "class
      Project". It has a number of attributes, including a string name,
      verbose flag, a list of actions, a list of channels, and a default
      formatter to use if none is specified. The channels are the
      connections between actions, and are simply tuple pairs of names of
      actions.
    </para>
    <section id="sourceaction-rules">
      <title>SourceAction Rules</title>
      <para>
        The rules used to selection files in the SourceAction are stored in
        a list, where each rule is a tuple. The first element of the tuple
        is a string denoting the type of rule, and the rest depends on the
        type. Available types of SourceAction rules are:
      </para>
      <variablelist>
        <varlistentry>
          <term>Simple</term>
          <listitem><para>
            A 'simple' rule that contains a list of filenames as the second
            tuple element. The filenames may be absolute or relative. For
            backwards compatibility, a single filename may be used instead
            of a list.
          </para>
          <programlisting>
('Simple', ['fred.py', 'baz.py'])
          </programlisting></listitem>
        </varlistentry>
        <varlistentry>
          <term>Glob</term>
          <listitem><para>
            Allows easy selection of a number of files in a project or
            subdirectory, without having to update the config when extra
            files are added or removed. There are three extra tuple
            elements: a list of directories, a glob string, and an integer
            recursion flag. The directory names are just strings, and may be
            absolute or relative. The glob string is a glob expression as
            used by unix shells: the special characters are '*'
            which matches to 0 or more characters, and ? which matches any
            one character. The recursion flag can be 0 or 1. If 1, then
            subdirectories of the listed directories are also searched.
          </para>
          <programlisting>
('Glob', ['src/', 'tools/'], '*.cc', 1)
          </programlisting></listitem>
        </varlistentry>
        <varlistentry>
          <term>Exclude</term>
          <listitem><para>
            Allows files matched by previous rules to be excluded from the
            list. Remember that the rules are processed in order, so later
            rules can add more files again. There is only one extra field
            which is a glob expression to match the whole pathname. In order
            to make matching directories easier, the filenames are always
            considered to have a '/' prepended before comparing to the glob
            expression. This means that if a CVS directory is in the current
            directory and its files' relative pathnames resemble 'CVS/Root',
            you can still match it with '/CVS/'. 
          </para>
          <programlisting>
('Exclude', '/CVS/')
          </programlisting></listitem>
        </varlistentry>
        <varlistentry>
          <term>Dir</term>
          <listitem><para>
            Backwards compatibility for an old version of non-recursive
            Glob: Has a single directory and a glob expression.
          </para>
          <programlisting>
('Dir', 'src/', '*.cc')
          </programlisting></listitem>
        </varlistentry>
        <varlistentry>
          <term>Base</term>
          <listitem><para>
            Backwards compatibility for an old version of recursive
            Glob: Has a single directory and a glob expression.
          </para>
          <programlisting>
('Base', 'src/', '*.cc')
          </programlisting></listitem>
        </varlistentry>
      </variablelist>
    </section>
    <section>
      <title>An example new config file</title>
      <example>
        <title>New config file</title>
        <para>
          This config file is borrowed from the Boost demo included in the
          Synopsis distribution. It has two HTML formatters, one which outputs
          framed documentation similar to JavaDoc's layout. The second has no
          frames, but instead allows browsing of the source directories. The
          source files are displayed with syntax highlighting, and clicking on
          names allows the user to view cross-reference information and
          documentation.
        </para>
        <mediaobject>
          <imageobject><imagedata fileref="boost-config" format="EPS"
          scale="50"
          ></imageobject>
          <imageobject><imagedata fileref="boost-config.png" format="PNG"></imageobject>
          <textobject><phrase>Test Sources -> C++ Parser -> File Cache ->
          Linker -> Combined Cache -> Formatter</phrase></textobject>
          <caption><para>
            Screenshot from GUI showing arrangement of Actions
          </para></caption>
        </mediaobject>
        <programlisting>
"""Synopsis Project File v1
This file is auto-generated. If you must make changes by hand, please make a backup just in case."""
class struct:
 def __init__(self,**args):
  for k,v in args.items(): setattr(self, k, v)

class Project:
  name = 'Boost Python'
  data_dir = './'
  verbose = 1
  actions = [
    ['FormatAction', 327, 237, 'HTML Formatter', struct(
      FilePages=struct(
        file_path='boost/%s',
        links_path='BoostLinks/%s',
        scope='',
        toc_files=[]
      ),
      FileTree=struct(
        link_to_pages=1
      ),
      InheritanceGraph=struct(
        direction='horizontal',
        min_group_size=5,
        min_size=3
      ),
      ModuleListing=struct(),
      ScopePages=struct(
        detail_formatters=['DetailAST', 'DetailCommenter', 'SourceLinker', 'XRefLinker'],
        heading_formatters=['Heading', 'ClassHierarchyGraph', 'DetailCommenter', 'SourceLinker', 'XRefLinker'],
        parts=['Heading', 'Summary', 'Inheritance', 'Detail'],
        summary_formatters=['SummaryAST', 'SummaryCommenter', 'SourceLinker', 'XRefLinker']
      ),
      XRefPages=struct(
        xref_file='BoostXRef/compiled.xref'
      ),
      comment_formatters=['quotehtml', 'summary', 'section'],
      datadir='/usr/local/share/synopsis',
      file_layout='Synopsis.Formatter.HTML.FileLayout.FileLayout',
      name='HTML',
      output_dir='BoostPython/',
      pages=['FramesIndex', 'ScopePages', 'ModuleListing', 'ModuleIndexer', 'FileTree', 'InheritanceTree', 'InheritanceGraph', 'FilePages', 'NameIndex', 'XRefPages'],
      structs_as_classes=1,
      stylesheet='style.css',
      stylesheet_file='../html.css',
      tree_formatter='TreeFormatter.TreeFormatter',
      verbose=1
    )],
    ['FormatAction', 450, 267, 'HTML Formatter - No Frames', struct(
      FilePages=struct(
        file_path='boost/%s',
        links_path='BoostLinks/%s',
        scope='',
        toc_files=[]
      ),
      FileTree=struct(
        link_to_pages=1
      ),
      InheritanceGraph=struct(
        direction='horizontal',
        min_group_size=5,
        min_size=3
      ),
      ModuleListing=struct(
        short_title='Namespaces'
      ),
      ScopePages=struct(
        detail_formatters=['DetailAST', 'DetailCommenter', 'SourceLinker', 'XRefLinker'],
        heading_formatters=['Heading', 'ClassHierarchyGraph', 'DetailCommenter', 'SourceLinker', 'XRefLinker'],
        parts=['Heading', 'Summary', 'Inheritance', 'Detail'],
        summary_formatters=['SummaryAST', 'SummaryCommenter', 'SourceLinker', 'XRefLinker']
      ),
      XRefPages=struct(
        xref_file='BoostXRef/compiled.xref'
      ),
      base_dir='boost/',
      comment_formatters=['quotehtml', 'summary', 'section'],
      datadir='/usr/local/share/synopsis',
      default_toc='ScopePages',
      file_layout='Synopsis.Formatter.HTML.FileLayout.FileLayout',
      name='HTML',
      output_dir='BoostPythonNF/',
      pages=['DirBrowse', 'ScopePages', 'ModuleListing', 'InheritanceTree', 'InheritanceGraph', 'FilePages', 'RawFilePages', 'NameIndex', 'XRefPages'],
      start_dir='boost/boost/',
      structs_as_classes=1,
      stylesheet='style.css',
      stylesheet_file='../html.css',
      tree_formatter='TreeFormatter.TreeFormatter',
      verbose=1
    )],
    ['SourceAction', 72, 41, 'Boost Sources', [
      ['Glob', ['boost/boost/'], '*.hpp', 1]
    ]],
    ['SourceAction', 73, 121, 'Boost Python Sources', [
      ['Glob', ['boost/boost/python/'], '*.hpp', 1]
    ]],
    ['ParserAction', 151, 57, 'C++ Parser', struct(
      basename='boost',
      defines=['PYTHON_INCLUDE=&lt;python2.2/Python.h&gt;', 'BOOST_PYTHON_SYNOPSIS'],
      emulate_compiler='g++-3.2',
      include_path=['boost', '/usr/include/python2.2'],
      main_file=1,
      name='C++',
      syntax_prefix='BoostLinks/',
      verbose=0,
      xref_prefix='BoostXRef/'
    )],
    ['CacherAction', 237, 57, 'File Cacher', 'BoostFiles', None],
    ['SourceAction', 71, 211, 'Test Source', [
      ['Simple', ['boost/boost/python/dict.hpp']]
    ]],
    ['LinkerAction', 326, 58, 'Combined AST', struct(
      XRefCompiler=struct(
        xref_file='BoostXRef/compiled.xref',
        xref_path='BoostXRef/%s'
      ),
      comment_processors=['dummy', 'ss'],
      name='Linker',
      operations=['Unduplicator', 'Stripper', 'NameMapper', 'Comments', 'EmptyNS', 'AccessRestrictor', 'XRefCompiler']
    )],
    ['CacherAction', 327, 145, 'Combined AST Cache', 'BoostFiles', '']
  ]
  channels = [
    ('C++ Parser', 'File Cacher'),
    ('File Cacher', 'Combined AST'),
    ('Test Source', 'C++ Parser'),
    ('Combined AST', 'Combined AST Cache'),
    ('Combined AST Cache', 'HTML Formatter'),
    ('Combined AST Cache', 'HTML Formatter - No Frames')
  ]
  default_formatter = 'HTML Formatter'
        </programlisting>
      </example>
    </section>
  </section>
  <section><title>Input: Parsing Source</title>
    <para>Source parsers?</para>
  </section>
  <section><title>Generating Documents</title>
    <para>Output formats</para>
  </section>
  <section><title>Full Configuration Reference</title>
      <!-- include Synosis.Config module from RefManual -->
      &config;
  </section>
</chapter>

<!-- vim: set ts=8 et sts=2 sw=2: -->
