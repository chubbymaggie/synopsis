<!-- Chapter 1 - an introduction to Synopsis -->
<chapter id="intro">
  <title>Introduction</title>
  <para>
    This chapter introduces Synopsis at a meta level: why it exists and
    what it is capable of so far.
  </para>
  <section id="intro-why">
    <title>Why Synopsis?</title>
    <para>
      There are already several similar systems in existance. Notable examples
      are JavaDoc which only works for Java, Doxygen which was designed to
      work with C++/Qt/KDE, Doc++ which was also designed for C++, and
      numerous other less common tools like happydoc, pydoc, etc. So what were
      they lacking that caused Synopsis to come into existance?
    </para>
    <para>
      The <ulink url="http://www.fresco.org/">Fresco project</ulink> uses a
      combination of CORBA IDL to define interfaces, C++ to implement the
      server, libraries and some clients, and Python for other clients. There
      was no single tool that could handle all three languages in a consistant
      manner, <emphasis>and</emphasis> create links between them. For example,
      the GraphicImpl class extends from POA_Fresco::Graphic, which is a
      skeleton generated by the CORBA IDL compiler corresponding to the IDL
      interface Fresco::Graphic. Synopsis allows the documentation for
      GraphicImpl to link directly to the interface Fresco::Graphic instead of
      POA_Fresco::Graphic.
    </para>
    <para>
      The Fresco project is also split up into multiple sub-projects. There is
      Babylon the Unicode library, Prague the POSIX layer, Fresco the CORBA
      IDL interface, Berlin the server, and many "kits", each a separate
      module loaded at runtime and compiled separately. It was desired that
      the documentation for these be separate, even though they have links
      between them. Synopsis uses "TOC" files (table of contents), which is
      simply a list mapping qualified entity names (eg:
      "Prague::Thread::self()") to URL's. The TOC file can be generated when
      creating documentation, and documentation can use existing TOC files to
      resolve unknown links. The TOC files can be specified with a prefix, eg:
      "http://src.fresco.org/docs/Prague/" for the Prague TOC. The prefix URL
      is combined with the URLs in the TOC file to generate the final link
      URLs. This allows the documentation for each sub-project to be generated
      separately, and even stored in separate places. Yet the documentation
      for each project is fully linked to the other documentation where
      references occur.
    </para>
  </section>
  <section id="intro-status">
    <title>Status of Synopsis</title>
    <para>
      As of this writing (Nov 18th, 2002), Synopsis is still somewhere between
      version 0.4 and 0.5. Like many open-source projects, it does not have a
      dedicated team of full time, paid programmers. Progress is therefore
      spotty at times and amazing at others, depending on the weather
      (sometimes quite literally!;) There has been interest lately in using
      Synopsis both for the whole Boost documentation as a C++ parser, and
      also for the Boost.Python project to generate different levels of
      documentation - reference and implementation.
    </para>
    <para>
      The following table summarizes the status of the individual components:
      <table frame="all">
        <title>Synopsis Component Status</title>
        <tgroup cols="2" colsep="1" rowsep="1">
          <colspec colname="name">
          <colspec colname="status">
          <thead>
            <row>
              <entry>Name</entry>
              <entry>Status</entry>
            </row>
          </thead>
          <tbody>
            <row><entry>C++ Parser</entry>
              <entry><para>
                The C++ Parser is implemented using "ucpp" for the preprocessor
                and "OpenC++" to generate a "parse-tree" from the preprocessor
                output. The parse-tree is then traversed to generate the AST,
                with extra information being temporarily stored to allow proper
                name lookup. The temporary AST is then converted into the final
                (Python) AST. 
                <itemizedlist>
                  <listitem><para>
                    There are no known bugs with ucpp remaining.
                  </para></listitem>
                  <listitem><para>
                    OpenC++ still ignores some keywords such as explicit.
                  </para></listitem>
                  <listitem><para>
                    The name lookup does not involve instantiating templates,
                    so argument dependent lookup does not work.
                  </para></listitem>
                  <listitem><para>
                    Includes and macros are handled but not yet stored in the
                    documentation.
                  </para></listitem>
                  <listitem><para>
                    Only one file can be parsed at a time.
                  </para></listitem>
                  <listitem><para>
                    Syntax highlighting and cross-reference information can be
                    generated and stored.
                  </para></listitem>
                </itemizedlist>
              </para></entry>
            </row>
            <row><entry>CORBA IDL Parser</entry>
              <entry><para>
                The IDL parser uses some of the modules from the "omniidl"
                parser, and hence omniidl must be installed and its Python
                modules must be in the PYTHONPATH or the system site-packages
                directory.
                <itemizedlist>
                  <listitem><para>
                    There is full support for IDL.
                  </para></listitem>
                  <listitem><para>
                    There is no syntax highlighting or cross-reference
                    information.
                  </para></listitem>
                </itemizedlist>
              </para></entry>
            </row>
            <row><entry>Python Parser</entry>
              <entry><para>
                The Python parser uses the 'symbol' and 'token' libraries that
                are builting to Python, and are the same parser that Python
                itself uses.
                <itemizedlist>
                  <listitem><para>
                    Only classes, functions, methods and variables are
                    extracted, with their relevant docstrings.
                  </para></listitem>
                  <listitem><para>
                    Name lookup can handle "import Foo from X" but not "import
                    * from X".
                  </para></listitem>
                  <listitem><para>
                    There is no syntax highlighting or cross-reference
                    information.
                  </para></listitem>
                </itemizedlist>
              </para></entry>
            </row>
            <row><entry>HTML Formatter</entry>
              <entry>
                This is the most highly developed formatter. It is very
                configurable, allow selection of different file layouts (one
                directory or nested), different "pages" (cross-reference,
                source, normal documentation, files) and different layouts
                (frames, no frames).
              </entry>
            </row>
            <row><entry>DocBook Formatter</entry>
              <entry>
                A basic docbook output formatter has been implemented, though
                it does not support all the AST features, nor any special
                comment formatting such as the @param java-style tags.
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      Todo: finish the table.
    </para>
  </section>
  <section>
    <title>Using Synopsis</title>
    <para>
      Synopsis supports both the command line and the GUI. Most configuration
      options can be specified on the command line except for the HTML
      formatter which is too complex. The preferred method is to store the
      configuration options in a config file, and only use command line
      options to specify which configuration to use.
    </para>
    <para>
      A GUI is under development, however it is not yet
      fully usable. It will allow easy configuration of Synopsis, and provide
      a GUI environment to execute projects and evaluate the results. A
      Project configuration was implemented to replace the previous Makefile
      dependency, and a new configuration file format that can be both read
      and written by Synopsis was created.
    </para>
  </section>
</chapter>
<!-- vim: set ts=8 et sts=2 sw=2: -->
