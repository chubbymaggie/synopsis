<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>
  <title>Synopsis User Manual</title>

  <chapter>
    <title>Introduction</title>

    <section>
      <title>What is Synopsis?</title>

      <para>Synopsis is a tool for creating documentation from source code,
      using both comments and the code itself - the code is actually parsed
      rather than just searching for comments and particular expressions.
      Currently Synopsis can parse C++, Python and CORBA IDL, and generate
      documentation in a range of formats including HTML, DocBook, PDF and Dia
      graphs.</para>

      <para>There are three stages in the documentation process: Parsing,
      Linking and Formatting. The data passed between each stage is an AST
      (Abstract Syntax Tree), a rich data structure which reflects the
      structure of the program. All three stages can be executed at once, or
      the AST can be stored to disk for later use.</para>

      <para>Parsing is performed by language-specific parser modules. The most
      advanced is the C++ parser which does correct name resolution and
      generates extra information used to syntax highlight the source code and
      cross-reference symbols.</para>

      <para>The Linking stage is where Synopsis derives most of its power,
      performing complex manipulations of the AST. At a minimum it handles the
      merging of multiple ASTs, eg: from different source files. It can
      manipulate the AST based on comments in the source, or perform things
      like renaming declarations to, for example, link directly to an IDL
      interface instead of a CORBA stub/skeleton.</para>

      <para>The Formatting stage generates the documentation from the AST
      output by the Linking stage. There are a number of modules, but the most
      common is the HTML module. The HTML formatter is very flexible, itself
      consisting of multiple &#34;Page&#34; modules each of which generates a
      part of the documentation (the index, the list of modules, the class
      documentation, the inheritance tree, etc.)</para>

      <para>Synopsis was written by Stephen Davies (aka Chalky) and Stefan
      Seefeld.</para>

      <para>This manual was written by Stephen Davies.</para>
    </section>

    <section>
      <title>How to use this manual</title>

      <para>Synopsis is very configurable, and this manual attempts to
      document all the features that can be enabled and how to configure them
      properly.</para>

      <para>The tutorial chapter shows some quick examples of how to get
      Synopsis working, and you can always check out the demos in the source
      distribution to see how some features work. Further chapters list all of
      the Parser, Linker and Formatter modules and all of the features/options
      available for each. Each feature has a detailed description, but for a
      quick reference you can also see the Config section of the Reference
      Manual generated from the Synopsis source code. You will also need the
      Reference Manual if you intend to write any extensions to Synopsis.</para>
    </section>

    <section>
      <title>How to use Synopsis</title>

      <para>Synopsis is a command-line tool, however a GUI may be included in
      future releases. Due to the highly configurable nature of Synopsis, it
      is not feasible to make a command line switch for each option. In order
      to aide testing and debugging of your configuration however, some of the
      more common options do have command line switches.</para>

      <para>So, the main way to configure Synopsis is with a config file,
      which is actually a Python script (usually config.py). This script is
      executed in a sandbox by Synopsis, and then its namespace is inspected
      to extract the configuration options. If you already know Python then
      you will have no problems reading and writing the script, and if you
      don&#39;t, well Python is really easy to learn - the Python tutorial
      included with Python will get you up to speed in half an hour or less!
      You don&#39;t need to know any of the builtin functions or libraries to
      write a config script.</para>

      <para>Synopsis uses three stages to generate documentation: parsing each
      source file to an AST (Abstract Syntax Tree), linking ASTs together and
      performing manipulations, and formatting the final AST. There are two
      ways to control this process:</para>

      <orderedlist>
        <listitem>
          <para>Use a Makefile, and run Synopsis multiple times. This allows
          you to integrate Synopsis with your existing build system. A simple
          Makefile has three rules: one to parse each source file to a .syn
          file, another to link all the .syn files into a single .syn file,
          and a third to format the final .syn file. All the configuration is
          stored in the config.py file and the only switches given to Synopsis
          are to indicate the stage of processing and the input/output
          filenames/directories.</para>
        </listitem>

        <listitem>
          <para>Use a Synopsis Project file. Project files are a new paradigm
          invented for the upcoming GUI which allows the entire process to
          execute with one synopsis command (eg: synopsis -P
          project.synopsis). It has some rules similar to make, with the
          exception that it does proper dependency checking and has flexible
          rules for selecting input files. The only downside is that in order
          to make the file easily readable and writable by the GUI it is much
          less readable and writable by hand.</para>
        </listitem>
      </orderedlist>

      <para>This manual will concentrate on the Makefile and config.py method,
      as this is the simplest to learn. All of the configuration options are
      valid in both files, with the exception of those for controlling the
      processing of the three stages in the second method.</para>

      <para>Synopsis can also integrate your project&#39;s documentation
      across multiple separate libraries or modules. An example is the best
      way to illustrate this: The Fresco Project has a Reference Manual for
      its IDL interfaces and its many implementation libraries and modules
      available online. Your project is a module which integrates with
      Fresco&#39;s display server, using both the IDL API and the display
      server&#39;s internal API. By downloading a .toc file (Table Of
      Contents) from the Fresco website, the documentation you generate for
      your project can link directly to Fresco&#39;s online documentation. For
      example, you have a method change_picture(Graphic g) where Graphic is an
      interface from the IDL API. In your documentation, Graphic will be a
      hyperlink to the documentation of the Graphic interface at the Fresco
      website. Neat huh? The Fresco documentation itself uses this feature to
      generate the documentation for each library separately, using .toc files
      to link to documentation of the libraries each library uses.</para>
    </section>

    <section>
      <title>Where to get more help</title>

      <para>Website: http://synopsis.sf.net</para>

      <para>Task/Bug/Patch/File manager at SourceForge:
      http://sourceforge.net/projects/synopsis/</para>

      <para>Mailing List: http://sourceforge.net/mail/?group_id=3169</para>

      <para>Reference Manual: Your distribution might have a -doc package for
      this, else it is in the docs/RefManual directory of the source
      distribution. This is a generated source code reference for Synopsis,
      but also included is complete documentation for the Configuration files
      (see the Config link in the top right of any page).</para>
    </section>
  </chapter>

  <chapter>
    <title>Tutorial</title>

    <section>
      <title>Running Synopsis</title>

      <para>Several demos are included with the source distribution, and are
      designed to be run without installing. However, if Synopsis is not
      installed then you will need to set your PYTHONPATH to include the
      Synopsis directory (the one with &#34;configure&#34;) and the
      &#34;share&#34; data (i.e.: icons) will not be accessible. There are
      demos for each parser, and some other feature demos, such as the Boost
      demo which documents Boost.Python and the Perceps demo which shows how
      to extend Synopsis to deal with &#34;strange&#34; commenting rules.</para>

      <para>Makefiles, stages, flags.</para>
    </section>

    <section>
      <title>The easy way: copy a demo config + modify</title>

      <para>The easiest way to get started using Synopsis is to copy a config
      file and maybe a Makefile from one of the demos.</para>

      <para>Let&#39;s say your project is called Player (it&#39;s a CD
      player!) has the following layout:</para>

      <programlisting>/src/Player/Makefile
/src/Player/src/player.cc     # main file
/src/Player/src/gui.cc        # GUI code
/src/Player/src/driver.cc     # CD playing code
/src/Player/include/driver.hh # Classes for the CD playing code
/src/Player/include/gui.hh    # Classes for the GUI code
/src/Player/syn/              # Intermediate Synopsis files will go here
/src/Player/doc/html/         # Synopsis documentation will go here</programlisting>

      <para>Since it is a C++ project, we will copy the simple-config.py from
      the C++ demo. The C++ demo has several examples it compiles, so the
      config.py file there is a bit more complex than we need.</para>

      <section>
        <title>The Makefile</title>

        <para>Your Makefile probably already has a variable FILES which lists
        the .cc files in src/, but Synopsis cares most about the header files.
        You will also need variables which contain the names of the .syn files
        generated by Synopsis&#39; parser, so add these lines to your
        Makefile:<programlisting># Project files
FILES = src/player.cc src/gui.cc src/driver.cc
INCLUDES = include/driver.hh include/gui.hh

# List of output .syn files for each input file
SYN_FILES = $(patsubst %,syn/%.syn,$(FILES) $(INCLUDES))</programlisting></para>

        <para>The patsubst line is a feature of (GNU) make that replaces a
        word (the %) with the word prefixed with syn/ (so the file goes in the
        syn directory) and suffixed with .syn (to mark it as a Synopsis file).
        This is done for both the source files and the include files.</para>

        <para>The first step is to add a rule which will compile your source
        files (including .hh files!) into Synopsis .syn files containing the
        parsed AST:<programlisting># A pattern rule to parse each input file
$(SYN_FILES): syn/%.syn: %
        # Here $@ is the output .syn file and $&#60; is the .cc or .hh file
        synopsis -c config.py -Wc,parser=C++ -o $@ $&#60;</programlisting></para>

        <para>The first line there is a pattern rule. It says that for each of
        the SYN_FILES, the output syn/%.syn depends on %. This means, for
        example, that syn/src/player.cc.syn depends on src/player.cc.</para>

        <para>The arguments to synopsis are:</para>

        <variablelist>
          <varlistentry>
            <term>-c config.py</term>

            <listitem>
              <para>Use the config file &#34;config.py&#34;. This is the
              Python script with the configuration options in it. We will get
              to this file later...</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-Wc,parser=C++</term>

            <listitem>
              <para>Gives the &#34;parser=C++&#34; option to the configuration
              module. Note that the -Wx,foo,bar style of command line option
              is borrowed from the GCC parser. Options are separated by commas
              and are passed to the relevant modules. Other modules you can
              address in this way are the parser
              (&#34;-Wp,-m,-s,myfile.cc.links&#34;), the linker
              (&#34;-Wl,-s,Foo::Bar&#34;) and the formatter
              (&#34;-Wf,-s,styleshee.css&#34;). In this case we are telling
              Synopsis to use the parser config with the name C++. This also
              tells it that the inputs are source files and must be parsed.
              See the config.py section below for more on this.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-o $@</term>

            <listitem>
              <para>Output the AST to $@, which will be expanded by Make to be
              the output file, eg: syn/src/player.cc.syn</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>$&#60;</term>

            <listitem>
              <para>Input file, which will be expanded by Make to be the first
              dependancy - the source file, eg: src/player.cc</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Next is a rule to combine the multiple .syn files into a single
        one containing the whole AST for your project:<programlisting># The combined AST file which is the result of linking all files together
COMBINED = syn/combined.syn

# Make the combined file depend on all the intermediate files
$(COMBINED): $(SYN_FILES)
        # Link all the files together
        synopsis -c config.py -Wc,linker=Linker -o $(COMBINED) $(SYN_FILES)</programlisting></para>

        <para>The arguments to synopsis here are:</para>

        <variablelist>
          <varlistentry>
            <term>-Wc,linker=Linker</term>

            <listitem>
              <para>Similar to the previous -Wc option, this one tells
              Synopsis to use the linker config named as &#34;Linker&#34; in
              the config file. Since we didn&#39;t specify a parser, Synopsis
              assumes that the inputs are binary .syn files containing parsed
              ASTs.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>$(SYN_FILES)</term>

            <listitem>
              <para>A small note that make expands this variable to many files
              (5 in our example). Multiple AST files can be passed to the
              Linker, or to a formatter (in which case Synopsis links them
              with default options).</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Finally, a rule to format the combined AST into the HTML output.
        This step and the previous one can be done in one go, but this way you
        can generate multiple output formats from the one AST.<programlisting># The (main) final output file
HTML = doc/html/index.html

# Make the output file depend on the combined file
$(HTML): $(COMBINED)
        # Run synopsis to generate output
        synopsis -c config.py -Wc,formatter=HTML $(COMBINED)</programlisting></para>

        <para>The arguments should be obvious by now:</para>

        <variablelist>
          <varlistentry>
            <term>-Wc,formatter=HTML</term>

            <listitem>
              <para>Tells Synopsis to use the formatter config named
              &#34;HTML&#34;.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Some housekeeping rules come last: A nice &#34;doc&#34; target
        so you can run &#34;make doc&#34;, and a clean target so you can run
        &#34;make clean&#34;. If you already have a clean target, just add
        this to your existing one.<programlisting># A doc target which creates the output file
doc:    $(HTML)

# A clean target which removes all the .syn files
clean:
        rm -rf $(COMBINED) $(SYN_FILES)</programlisting></para>

        <para>The final Makefile looks like this:<programlisting># Project files
FILES = src/player.cc src/gui.cc src/driver.cc
INCLUDES = include/driver.hh include/gui.hh

# List of output .syn files for each input file
SYN_FILES = $(patsubst %,syn/%.syn,$(FILES) $(INCLUDES))

# The (main) final output file
HTML = doc/html/index.html

# The combined AST file which is the result of linking all files together
COMBINED = syn/combined.syn

# A doc target which creates the output file
doc:    $(HTML)

# A clean target which removes all the .syn files
clean:
        rm -rf $(COMBINED) $(SYN_FILES)

# Make the output file depend on the combined file
$(HTML): $(COMBINED)
        # Run synopsis to generate output
        synopsis -c config.py -Wc,formatter=HTML $(COMBINED)

# Make the combined file depend on all the intermediate files
$(COMBINED): $(SYN_FILES)
        # Link all the files together
        synopsis -c config.py -Wc,linker=Linker -o $(COMBINED) $(SYN_FILES)

# A pattern rule to parse each input file
$(SYN_FILES): syn/%.syn: %
        # Here $@ is the output .syn file and $&#60; is the .cc or .hh file
        synopsis -c config.py -Wc,parser=C++ -o $@ $&#60;</programlisting></para>

        <para>You can find this Makefile in demo/Tutorial/Player.</para>
      </section>

      <section>
        <title>The config.py file</title>

        <para>Now that the Makefile is written it&#39;s time to look at the
        config file. The simple-config.py looks like this:<programlisting># Config file for C++ demos
# Only some files have comments in //. style
 
from Synopsis.Config import Base
 
class Config (Base):
    class Parser:
        class CXX (Base.Parser.CXX):
            main_file = 1
        modules = {
            &#39;C++&#39;:CXX,
        }
             
    class Linker:
        class LinkerJava (Base.Linker.Linker):
            comment_processors = [&#39;java&#39;, &#39;javatags&#39;, &#39;summary&#39;]
        modules = {
            &#39;Linker&#39;:LinkerJava,
        }
 
    class Formatter:
        class HTML (Base.Formatter.HTML):
            stylesheet_file = &#39;../html.css&#39;
 
        modules = Base.Formatter.modules
        modules[&#39;HTML&#39;] = HTML</programlisting></para>

        <para>It is important to remember that the config.py file is a real
        python script and is executed just like a Python program. This has the
        advantage of allowing familiar syntax and flexibility, but at the
        expense of a little security risk - however generating documentation
        for source code is probably less risky than running the source code
        itself, and a config.py file is easier to check.</para>

        <para>The first Python line is to access the &#34;default&#34; config
        options in the module Synopsis.Config. The default options are stored
        in the Base class, which has many subclasses for the different
        modules. You can see these in either the Config.py file itself, or in
        the generated reference manual. It is not strictly necessary to use
        the Base class, but it simplifies the config file somewhat by
        providing many sensible defaults.</para>

        <para>The rest of the file defines a class called Config, which has
        three subclasses called Parser, Linker and Formatter, representing the
        three stages of processing. Each of these subclasses contains a
        &#34;modules&#34; dictionary which lists different named
        configurations for that stage. Usually the only use for having
        different configurations is to use different modules (different
        parsers, different formatters), but you can also have multiple
        configurations for the same module. The most common example of this is
        to have multiple Linker configurations for different commenting styles
        and other options.</para>

        <para>Let&#39;s examine the file a section at a time:<programlisting>class Config (Base):</programlisting></para>

        <para>The Config class derives from the Base class (that we imported
        at the start of the file) which has a constructor to sort out the
        configurations in the config class. Remember that Python uses
        indentation to indicate scope, so the lines after this are all
        indented to indicate that they are part of the Config class.<programlisting>class Parser:</programlisting></para>

        <para>This is the first subclass, containing configurations for the
        Parser stage.<programlisting>class CXX (Base.Parser.CXX):
    main_file = 1</programlisting></para>

        <para>This is the only parser configuration in this config file.
        Configurations are classes too, but they are instantiated when they
        are used so they can have constructors to set options at run time.
        This configuration class is called &#34;CXX&#34; and derives from the
        class Base.Parser.CXX which has some default config options and also a
        constructor (so be sure to call it if you write your own).</para>

        <para>Configuration options are set as attributes in the config
        object, which the parser examines when it runs. The only one here sets
        the &#34;main_file&#34; option to &#34;1&#34;. See later chapters in
        this manual for more options, or the reference manual for a complete
        list.<programlisting>modules = {
    &#39;C++&#39;:CXX,
}</programlisting></para>

        <para>This little bit of code sets an attribute in the Parser class
        called modules, to a dictionary (note the braces aka curly brackets)
        of named configurations. Here &#39;C++&#39; is the name of the
        configuration to be used on the command line, and CXX (no quotes!)
        refers to the CXX class in the current scope. Note that the class was
        called CXX rather than C++ since C++ is not a valid class name.</para>

        <para>There is just one thing missing here: how does Synopsis actually
        know to use the C++ parser for this config? Surely it doesn&#39;t go
        by the name... The answer lies in the fact that we derived from the
        default configuration class Base.Parser.CXX. Looking in the Config.py
        file shows (amongst other things):<programlisting>class CXX:
    name = &#39;C++&#39;</programlisting></para>

        <para>Synopsis uses the name, along with the fact that the
        configuration was in the Parser section, to make the module name
        &#34;Synopsis.Parser.C++&#34;, load the module and look for a
        &#34;parse&#34; function. It turns out that C++ is a valid name for a
        package in Python, but only if you use the import() function (rather
        than an import statement). If you look in the site-packages directory
        (e.g. /usr/lib/python2.2/site-packages) you will see the file
        Synopsis/Parser/C++/__init__.py, which is the module actually loaded
        to get the C++ parser.</para>

        <para>To use a parser for a different language, the easiest thing to
        do is derive from one of Base.Parser.IDL or Base.Parser.Python, as
        appropriate. Note that the different parsers generally have different
        options.</para>

        <para>Getting back to the config file, the Linker section is pretty
        similar to the Parser section, except for this line:<programlisting>comment_processors = [&#39;java&#39;, &#39;javatags&#39;, &#39;summary&#39;]</programlisting></para>

        <para>The syntax here is setting the comment_processors attribute to a
        list of strings. The (square) brackets indicate a list (parentheses
        aka round brackets indicate a tuple, which is an immutable list).
        Strings can be either single or double quotes - Python makes no
        distinction between the two so it&#39;s just a matter of style.</para>

        <para>This particular option tells the Linker to apply the three
        comment processors called &#39;java&#39;, &#39;javatags&#39; and
        &#39;summary&#39; in that order. Comment processors are operations
        that use the comments attached to declarations to perform
        manipulations of either the comments or the AST itself:<variablelist><varlistentry><term>java</term><listitem><para>Looks
        for comments with the java commenting style of /** foo bar */. Any
        comments not matching this format are removed, and then the /** and */
        strings are also removed. Intermediate lines must begin with a *, so a
        multi-line comment looks like:<programlisting>/** The first sentence is a summary.
 * The rest of the comment goes here, with each line
 * beginning with a star. The closing star-slash can go
 * either by itself or at the end of a line.
 */</programlisting></para></listitem></varlistentry><varlistentry><term>javatags</term><listitem><para>Comments
        can have special &#34;tags&#34; which indicate either processing or
        formatting. This processor extracts the JavaDoc style tags from the
        comments and stores them with the comment for other processors or
        formatters to use. The tags must be at the end of the comment, but
        this allows them to span multiple lines if necessary. An example of
        JavaDoc tags is:<programlisting>/** Returns the height of the given person.
 * @param firstname the first name of the person
 * @param surname the surname of the person
 * @return the height of the person or 0 if the person was not found
 */
float getHeight(std::string firstname, std::string surname);</programlisting></para></listitem></varlistentry><varlistentry><term>summary</term><listitem><para>This
        processor extracts a summary of each comment and stores it with the
        comment, allowing the documentation to display a (usually one line)
        summary next to declarations in order to keep the pages tidy, and show
        the full comments elsewhere (e.g. further down the page). This
        processor also combines the comments for each declaration, so it
        should be the last one in the list.</para></listitem></varlistentry></variablelist></para>

        <para>See chapter XXX for a full list of comment processors.</para>

        <para>The HTML formatter we will have to change slightly. The
        stylesheet_file option tells the HTML formatter where to read the
        stylesheet from, and since the demo&#39;s are designed to run without
        Synopsis being installed, this is probably wrong. The default is to
        use the one installed in $prefix/share/Synopsis, so you can either
        delete the line or set it to the correct path. If you delete it,
        remember that Python needs the word &#34;pass&#34; for an empty class
        (or function):<programlisting>class HTML (Base.Formatter.HTML):
    pass</programlisting>Finally, the way the modules dictionary is set for
        the Formatter is a bit different. Here we first set it to the default
        value from the base class, then overwrite the entry for HTML with the
        new HTML formatter configuration. By using the default value like
        this, you get (default) configurations for all the different
        formatters.</para>
      </section>

      <section>
        <title>The output explained</title>

        <para>That&#39;s it! Just run &#34;make doc&#34; and hopefully it
        should all work. You will see Synopsis being run for each input file,
        to combine the ASTs, and the format the output.</para>

        <para>The HTML is output to whatever directory you set in the
        Makefile, which was written above as doc/html/. Point your web browser
        at the index.html file there to view the documentation, and you will
        see three frames (using the default configuration) similar to JavaDoc
        documentation:<variablelist><varlistentry><term>Top-left
        &#34;contents&#34; frame</term><listitem><para>This frame shows a tree
        heirarchy of the modules or files in the project. Clicking on a link
        opens that module or file in the &#34;index&#34; frame below.</para></listitem></varlistentry><varlistentry><term>Bottom-left
        &#34;index&#34; frame</term><listitem><para>This frame shows an index
        of the currently selected module or file, but only shows child
        classes, structs, namespaces or modules. When a module page is loaded
        in this frame and you have JavaScript enabled, a more detailed page
        will open in the main content area. For file pages you will need to
        click the &#34;File Details&#34; link.</para></listitem></varlistentry><varlistentry><term>Right
        &#34;main&#34; frame</term><listitem><para>This frame shows the main
        documentation. At the top of each page you can see a list of
        documentation areas you can visit: The Modules and Files open in the
        top-left frame, the Inheritance Graph/Tree and Name Index load in the
        main frame. For &#34;scope pages&#34; (i.e. the pages for classes and
        namespaces, including the global namespace which is the default page)
        the page is divided into summary and detail sections: the summary
        shows all the declarations in this class or namespace, with a summary
        for each. For declarations with more comments than just the summary,
        the name of the declaration will be highlighted, and clicking on it
        will take you to its detailed information further down the page.</para></listitem></varlistentry></variablelist></para>

        <para>You can also try out the other formatters. To see which
        formatters are available, run &#34;synopsis -l&#34;. To use a
        particular formatter, type:<programlisting>$ synopsis -c config.py -Wc,formatter=Dia -o player.dia syn/combined.syn</programlisting></para>

        <para>to use configuration from the config.py file (in our config file
        we just inherited the default options anyway), or you can just use the
        default options by typing:<programlisting>$ synopsis -f Dia -o player.dia syn/combined.syn</programlisting></para>

        <para>You can also pass command line options to the formatter with the
        following syntax:<programlisting>$ synopsis -f Dia -Wf,-p -o player.dia syn/combined.syn</programlisting></para>

        <para>This passes the -p option to the formatter. For the Dia
        formatter this tells it not to include parameters.</para>
      </section>
    </section>

    <section>
      <title>The hard way: create from scratch</title>

      <para>Allows flexibility. Mention deriving from Config.Base</para>
    </section>

    <section>
      <title>The powerful way: new config format</title>

      <para>Replace make. used by GUI. hard to read/write.</para>
    </section>

    <section>
      <title>The future way: use the GUI</title>

      <para>In some future release there will be a GUI to allow easy
      configuration of Synopsis.</para>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>The Parsers</title>

    <section>
      <title>C++ Parser</title>

      <para>most advanced. SXR. XREF. UCPP, OCC</para>

      <para>The C++ parser reads C++ source code and generates an AST. It is
      the most advanced Synopsis parser, using the following components:<itemizedlist><listitem><para>A
      modified version of UCPP by Thomas Pornin. The modifications are to
      improve C++ standards conformance, and add features needed by Synopsis
      such as storing information about #includes and #defines, and recording
      the position of every macro expansion.</para></listitem><listitem><para>A
      modified version of OpenC++ (OCC) by Shigeru Chiba and others. OCC is
      used to generate a &#34;parse-tree&#34; from the preprocessed source
      code. The parse-tree is a data structure that directly represents the
      syntax of the source code. OCC uses Hans Boehm&#39;s garbage collector,
      but this can be disabled by passing --disable-gc to configure.</para></listitem><listitem><para>Code
      to &#34;walk&#34; the parse-tree and build an Abstract Syntax Tree. A
      symbol table is also maintained which is used to correctly resolve all
      types according to the C++ standard.</para></listitem><listitem><para>Code
      to record the positions of all macro expansions, keywords, comments,
      type and name references if SXR or XREF (see below) is enabled.</para></listitem><listitem><para>Miscellenous
      code to convert the C++ AST to a Python data structure, maintain the
      list of files, implement a Python module etc.</para></listitem></itemizedlist></para>

      <para>Like a compiler, the C++ parser has to parse the whole translation
      unit for each file to make sure it has the correct type references.
      Unfortunately this means it has to wade through all the standard library
      headers for each input file which, like with a compiler without
      precompiled headers, can take a long time. Luckily the C++ parser is
      written in C++ for speed and has been optimised in critical areas. If
      you are not using SXR or XREF then it skips all method bodies which
      speeds things up, and even if you are it only has to resolve type and
      function call information - there is no code generation or optimisation
      going on.</para>

      <para>Fortunately you can parse multiple headers in one go if you have a
      main header file which includes everything else (such as how
      python2.2/Python.h includes the other 41 Python header files), and if
      you are using a Project config file. See the multiple_files option
      below.</para>

      <section>
        <title>SXR and XREF</title>

        <para>So what are SXR and XREF?</para>

        <para>SXR stands for Synopsis Cross Reference. It is a combined
        feature of the C++ parser and the HTML formatter which displays the
        source code but with hyperlinks for every type reference and every
        name reference.</para>

        <para>This means that if you click on a method signature in the source
        code, you will be taken to the documentation. Each declaration in the
        documentation will also have a link to the source code. Variable and
        type references in the source code also have &#34;titles&#34;, which
        show as tooltips if you hover the mouse over them, telling you what
        they are (eg: &#34;parameter Person&#34; or &#34;member variable
        std::string&#34;). Note that because Synopsis uses a real C++ parser
        the links are always to the right declarations - unlike other systems
        which use purely string based references which are often ambiguous!</para>

        <para>XREF stands for Cross Reference. This feature creates an index
        of all references to every declaration, including function and method
        calls. This allows you to follow a call graph, or see where a method
        or class is used (useful for refactoring!)</para>

        <para>Both of these features need to be coordinated with both the C++
        parser and the HTML formatter.</para>

        <para>For SXR you need: C++ Parser: syntax_prefix, blah. HTML
        Formatter: The pages option must include &#39;FileSource&#39;.</para>

        <para>For XREF you need: C++ Parser: xref_prefix, blah. HTML
        Formatter: The pages option must include &#39;XRefPages&#39;.</para>

        <para>Note that in the current release there are some limitations with
        respect to expressions that are understood, and template
        instantiations are not supported very well. This means that in the
        source code some methods will not be hyperlinked and some cross
        references will be missing.</para>
      </section>

      <section>
        <title>Options</title>

        <para><variablelist><varlistentry><term>name (string)</term><listitem><para>Name
        of this config object: Must be &#39;C++&#39;</para></listitem></varlistentry><varlistentry><term>verbose
        (boolean)</term><listitem><para>Verbosity flag. For config files, this
        attribute is set by the constructor, but only if &#39;verbose&#39; was
        passed as a config option.</para><para>Can be set to true from the
        command line with &#34;-Wp,-v&#34;</para></listitem></varlistentry><varlistentry><term>main_file
        (boolean)</term><listitem><para>Flag that selects if should only store
        the AST generated from the file(s) being processed, and not included
        files. The default is 1 (true).</para><para>Can be set to true from
        the command line with &#34;-Wp,-m&#34;</para></listitem></varlistentry><varlistentry><term>basename
        (string)</term><listitem><para>A file path to strip from the start of
        all filenames before storing. Setting this option for example will
        remove any redundant parent directories in the HTML FileListing page.</para><para>Can
        be set from the command line with, e.g.:
        &#34;-Wp,-b,../some/basename/&#34;</para></listitem></varlistentry><varlistentry><term>include_path
        (list of strings)</term><listitem><para>A list of paths to add to the
        include path. For example: [&#39;/usr/local/corba/&#39;,
        &#39;../include&#39;]</para><para>Can be set from the command line
        with, e.g.: &#34;-Wp,-I,/usr/local/corba/,-I,../include&#34;</para></listitem></varlistentry><varlistentry><term>defines
        (list of strings)</term><listitem><para>A list of defines to pass to
        the preprocessor. For example: [&#39;FOO&#39;, &#39;BAR=true&#39;]</para><para>Can
        be set from the command line with, e.g.:
        &#34;-Wp,-D,FOO,-D,BAR=true&#34;</para></listitem></varlistentry><varlistentry><term>preprocessor
        (string)</term><listitem><para>Which preprocessor to use. Not setting
        this causes the builtin ucpp to be used, which can track macro
        expansions when doing SXR stuff and extract macro definitions for the
        documentation. Setting it to &#39;gcc&#39; will cause gcc (well,
        really g++) to be used instead, for use only in cases when ucpp
        can&#39;t parse your standard libraries (usually because of compiler
        specific syntax). There are no other settings.</para><para>Can be set
        to gcc from the command line with &#34;-Wp,-g&#34;</para></listitem></varlistentry><varlistentry><term>extract_tails
        (boolean)</term><listitem><para>If set to true, then the parser will
        look for trailing comments before close braces. If it finds them, it
        will create dummy declarations to hold the comments. If you set this,
        you should probably also use the &#39;dummy&#39; or &#39;prev&#39;
        comment processors in the Linker options otherwise you will see the
        Dummy declarations in your documentation.</para><para>Can be set to
        true from the command line with &#34;-Wp,-t&#34;</para></listitem></varlistentry><varlistentry><term>storage
        (string)</term><listitem><para>If set, this must be a string which
        defines the file to store links into. Setting this also causes the
        parser to look more carefully at the input file, so that it can
        generate the links from inside blocks of code (otherwise it skips over
        them). Note that you usually set this from the command-line with your
        Makefile via &#34;-Wp,-s,$@.links&#34; or something. (deprecated)</para></listitem></varlistentry><varlistentry><term>syntax_prefix
        (string)</term><listitem><para>If set, must be a string which defines
        a prefix to store syntax info into. The source filenames are appended
        to the prefix to create the output filename, so it should be a
        directory name to avoid clashes (there is no suffix!). For example, if
        your file is &#34;src/foo.cc&#34; and prefix is &#34;syn/&#34; then
        the syntax information will be stored in &#34;syn/src/foo.cc&#34;.</para></listitem></varlistentry><varlistentry><term>xref_prefix
        (string)</term><listitem><para>If set, must be a string which defines
        a prefix to store xref info into. See syntax_prefix.</para></listitem></varlistentry><varlistentry><term>syntax_file
        (string)</term><listitem><para>If set, must be a string with the file
        to store syntax info into. Note that the syntax info can only hold
        syntax information about one source file, so this option is of limited
        use in a config file.</para><para>Can be set from the command line
        with, e.g: &#34;-Wp,-s,syn/&#34;</para></listitem></varlistentry><varlistentry><term>xref_file
        (string)</term><listitem><para>If set, must be a string with the file
        to store xref info into. Note that the xref info can only hold xref
        information about one source file, so this option is of limited use in
        a config file.</para><para>Can be set from the command line with,
        e.g.: &#34;-Wp,-x,xref/&#34;</para></listitem></varlistentry><varlistentry><term>fake_std
        (boolean)</term><listitem><para>If set, this causes the parser to
        construct a fake using directive from the std namespace to the global
        namespace. In effect, this fixes problems seen with using the stdc++
        headers for gcc 2.95.x where most things dont get placed in the std
        namespace.</para><para>Can be set to true from the command line with
        &#34;-Wp,-f&#34;</para></listitem></varlistentry><varlistentry><term>multiple_files
        (boolean)</term><listitem><para>If set to true then the parser handles
        multiple files included from the main file at the same time. This
        option can only be used with the Project file. If syntax_prefix or
        xref_prefix is set then the extra files will get syntax and xref nfo
        recorded into the appropriate files. Only one AST is output, but it is
        as if the ASTs for the individual files were already linked.</para><para>To
        use this option, your Project file must have a single SourceAction
        connected to this ParserAction. The SourceAction should have a Simple
        rule first which is the main sourcefile, and any number of other rules
        to select other files to record the AST for.</para></listitem></varlistentry></variablelist></para>
      </section>
    </section>

    <section>
      <title>Python Parser</title>

      <para>The Python parser uses Python&#39;s parser library to create an
      AST from Python source code. This is adequate for the purposes of
      extracting classes, methods and their comments, but prevents the
      advanced features like syntax highlighting since the parse tree does not
      store line number information. There is no support for SXR or XREF
      features.</para>

      <section>
        <title>Options</title>

        <para></para>

        <variablelist>
          <varlistentry>
            <term>name (string)</term>

            <listitem>
              <para>Name of this config object: Must be &#39;Python&#39;</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>verbose (flag)</term>

            <listitem>
              <para>Verbosity flag. For config files, this attribute is set by
              the constructor, but only if &#39;verbose&#39; was passed as a
              config option.</para>

              <para>Can be set from the command line with &#34;-Wp,-v&#34;</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>basename (string)</term>

            <listitem>
              <para>A file path to strip from the start of all filenames
              before storing. Setting this option for example will remove any
              redundant parent directories in the HTML FileListing page.</para>

              <para>Can be set from the command line with, e.g.:
              &#34;-Wp,-b,../some/basename/&#34;</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section>
      <title>CORBA IDL Parser</title>

      <para>The CORBA IDL Parser uses OmniORB&#39;s (Python) IDL compiler
      library to parse IDL files and generate an AST. You will need to have
      the omniidl package installed to use this parser. There is no support
      for SXR or XREF features.</para>

      <variablelist>
        <varlistentry>
          <term>name (string)</term>

          <listitem>
            <para>Name of this config object: Must be &#39;IDL&#39;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>verbose (boolean)</term>

          <listitem>
            <para>Verbosity flag. For config files, this attribute is set by
            the constructor, but only if &#39;verbose&#39; was passed as a
            config option.</para>

            <para>Can be set to true from the command line with
            &#34;-Wp,-v&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>main_file (boolean)</term>

          <listitem>
            <para>Flag that selects if should only store the AST generated
            from the file(s) being processed, and not included files. The
            default is 1 (true).</para>

            <para>Can be set to true from the command line with
            &#34;-Wp,-m&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>basename (string)</term>

          <listitem>
            <para>A file path to strip from the start of all filenames before
            storing. Setting this option for example will remove any redundant
            parent directories in the HTML FileListing page.</para>

            <para>Can be set from the command line with, e.g.:
            &#34;-Wp,-b,../some/basename/&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>include_path (list of strings)</term>

          <listitem>
            <para>A list of paths to add to the include path. For example:
            [&#39;/usr/local/corba/&#39;, &#39;../idl&#39;]</para>

            <para>Can be set from the command line with, e.g.:
            &#34;-Wp,-I,/usr/local/corba/,-I,../idl&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>keep_comments (boolean)</term>

          <listitem>
            <para>If true, comments will be stored in the AST. The default is
            true.</para>

            <para>Can be set to true from the command line with
            &#34;-Wp,-K&#34; (note upper case K)</para>

            <para>Can be set to false from the command line with
            &#34;-Wp,-k&#34;</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>

  <chapter>
    <title>The Linker</title>

    <para>The Linker is one of the more powerful features of Synopsis. It is
    actually a slight misnomer, since it does more than just linking multiple
    ASTs together - it can also move subtrees around, remove subtrees, map
    declaration names or type names, and perform various operations to do with
    comments.</para>

    <para>Unlike the Parsers and Formatters, there is only one Linker. It does
    however have a number of modules to perform various operations on the AST.
    The operation modules to use are specified in the &#34;operations&#34;
    config option. They should generally be in the order given by the
    following sections. See below for a list of all the Linker options.</para>

    <section>
      <title>Unduplicator</title>

      <para>The unduplicator is responsible for cleaning up the mess from
      merging multiple ASTs. The problem is that each AST has its own copy of
      any duplicate classes and functions, and the types are generally wrong
      even if there were no duplicate declarations. The unduplicator walks the
      whole AST ensuring that each declaration only occurs once, that the
      types dictionary refers to the one correct declaration, and that every
      &#34;declared&#34; type refers to the correct declaration. It takes
      special care to handle &#34;Modules&#34; (eg: C++ namespace and IDL
      modules) by combining them into MetaModule AST nodes. Nested classes
      declared outside the original class are also taken care of.</para>

      <para>There are no options for the Unduplicator, but you will always
      need it if you are combining multiple ASTs.</para>
    </section>

    <section>
      <title>Stripper</title>

      <para>The stripper compares every name in the AST to a list of prefixes.
      Note that names here are scoped names, such as
      &#34;boost::any::any_base::get_obj()&#34; or
      &#34;Synopsis.Formatter.HTML.core.format()&#34;. If a name matches, the
      prefix is stripped. If a name doesn&#39;t match any prefix, it is
      removed from the AST. If no prefixes are specified then the Stripper
      does not do anything (it doesn&#39;t even walk the tree so there is no
      performance penalty).</para>

      <para>This can be used to select parts of an AST to generate separate
      documentation. For example, the Synopsis RefManual splits the whole
      Synopsis AST into sections for formatting into different .info files.</para>
    </section>

    <section>
      <title>NameMapper</title>

      <para>This simple operation adds a prefix to every declaration and type
      name in the AST. The Synopsis RefManual uses this to move the whole C++
      AST into the Synopsis.Parser.C++ module.</para>
    </section>

    <section>
      <title>Comments</title>

      <para>This is the most complex Linker operation, since it is itself
      composed of multiple &#34;comment processors&#34; which work on comments
      attached to declarations. They should generally be in the following
      order, if present. You will always need a comment-identifier processor
      first, and the summary processor last.</para>

      <section>
        <title>ssd</title>

        <para>This processor identifies comments in the //. style. Any comment
        line not starting with //. will be removed, and the //. is stripped
        from those that do have it.<programlisting>//. This is a comment
//. With multiple lines</programlisting></para>
      </section>

      <section>
        <title>ss</title>

        <para>This processor identifies comments in the // style. Any comment
        line not starting with // will be removed, and the // is stripped from
        those that do have it.<programlisting>// This is a comment
// With multiple lines</programlisting></para>
      </section>

      <section>
        <title>java</title>

        <para>This processor identifies comments in the /** .. */ style. Any
        comment not beginning with /** and ending with */ will be removed, and
        the /**, */ and any * at the start of a line are stripped from those
        that have them.<programlisting>/** This is a comment
 * With multiple lines */</programlisting><programlisting>/** This is a comment
 * With multiple lines
 */</programlisting></para>
      </section>

      <section>
        <title>qt</title>

        <para>This processor identifies comments in the Qt style. There are
        two types of comments: brief and detail. Brief starts with //! and
        there must be only one. Detail comments are surrounded by /*! and */.<programlisting>//! Summary of this comment
/*! More info about the declaration
    There can be multiple lines.
    Must end with */</programlisting></para>
      </section>

      <section>
        <title>group</title>

        <para>Looks for sequences of declarations to group together by looking
        for a &#39;{&#39; in a comment and a &#39;}&#39; in a following
        comment in the same scope. The &#39;{&#39; and &#39;}&#39; must be at
        the beginning of a line, but may have a group name after them on the
        same line. For example:<programlisting>class Foo {
public:
    //. Methods for accessing attributes of
    //. this Foo
    //. { Accessor methods
    //. Get a Bar
    Bar* get_bar();
    //. Set the Bar
    //. @param bar the Bar to set
    void set_bar(Bar* bar);
    //. }
};</programlisting></para>

        <para>Note that you will need to set &#39;extract_tails&#39; in the
        C++ parser for the above example to work, since the last comment is
        between the last declaration and a closing brace! If you set
        extract_tails, you will also need one of &#39;dummy&#39; or
        &#39;prev&#39;.</para>
      </section>

      <section>
        <title>dummy</title>

        <para>Removes the dummy declarations created by setting
        &#34;extract_tails&#34; in the C++ parser. Any comments they had are
        lost. See the &#39;prev&#39; processor below.</para>
      </section>

      <section>
        <title>prev</title>

        <para>Checks comments to see if they start with a &#39;&#60;&#39;. If
        so, they are moved to the previous declaration. Any dummy declarations
        are removed once the comments have been checked. This can be used to
        put the comments after the declarations, like so:<programlisting>void func();
//.&#60; Some function

//. My enumeration
enum Foo {
  One, //.&#60; The first enumerator
  Two, //.&#60; The second
  Three //.&#60; The third
};</programlisting></para>

        <para>Note that it does not work for function parameters. To document
        parameters, enable the &#39;javatags&#39; processor and use
        &#34;@param&#34; tags in your comments.</para>
      </section>

      <section>
        <title>javatags</title>

        <para>Extracts java-style @tags from the ends of comments, and stores
        them in the tags() list of the Comment object. Each tag is a
        CommentTag object. The tags may be inspected by the formatters or
        other processors.</para>

        <para>You will need to use this processor if you want to use
        java-style @tags, since the HTML formatter no longer looks for them
        itself.</para>
      </section>

      <section>
        <title>summary</title>

        <para>This processor joins all the comments together for each
        declaration then attempts to make a summary of the comment from the
        first sentence. The summary is stored with the comment. It is used by
        the formatters extensively so you will almost always want this
        processor.</para>
      </section>
    </section>

    <section>
      <title>EmptyNS</title>

      <para>This operation walks the AST looking for empty modules/namespaces
      and removes them. A namespace is empty even if it just has Forward
      declarations in it. Note that any types referring to these forward
      declarations will still have the correct name, and will probably point
      to the correct (non-forward) declarations anyway since Unduplicator is
      usually before EmptyNS.</para>
    </section>

    <section>
      <title>AccessRestrictor</title>

      <para>If the config option max_access is set, then this operation walks
      the AST and removes any class members without enough accessibility.</para>
    </section>

    <section>
      <title>LanguageMapper</title>

      <para>This simple operation, which is not in the list of
      linker_operations by default, moves all global declarations into modules
      based on their language. This means you can mix declarations of
      different languages (e.g: IDL and C++), and if one references the other
      (perhaps due to NameMapper) it will look like: IDL::Fresco::WidgetKit
      instead of just Fresco::WidgetKit. It will also prevent clashes if you
      have both an IDL Fresco::WidgetKit and a C++ Fresco::WidgetKit.</para>
    </section>

    <section>
      <title>Linker options</title>

      <para>Rather than mix the options in with the above sections, they are
      listed here:<variablelist><varlistentry><term>verbose (boolean)</term><listitem><para>Verbosity
      flag. For config files, this attribute is set by the constructor, but
      only if &#39;verbose&#39; was passed as a config option.</para><para>Can
      be set to true from the command line with &#34;-Wl,-v&#34;</para></listitem></varlistentry><varlistentry><term>operations
      (list of strings)</term><listitem><para>If set, overrides the default
      list of operations to use in the Linker stage. Note that all operations
      except LanguageMapper do nothing without other options being set, so the
      default list is:</para><para>[ &#39;Unduplicator&#39;,
      &#39;Stripper&#39;, &#39;NameMapper&#39;, &#39;Comments&#39;,
      &#39;EmptyNS&#39;, &#39;AccessRestrictor&#39; ]</para><para>Note that
      the operations are executed in order.</para></listitem></varlistentry><varlistentry><term>strip
      (list of strings)</term><listitem><para>If set, causes the Stripper
      operation to strip prefixes from names in the list, and remove
      declarations which don&#39;t match any prefix. Typical usage just has
      one prefix. Each prefix is a scoped name, with the scopes separated by
      &#34;::&#34;.</para><para>Can be set on the command line with, e.g.:
      &#34;-Wl,-s,Synopsis::Parser::C++&#34;</para></listitem></varlistentry><varlistentry><term>mapper_list
      (list of: strings or 2-tuples of strings)</term><listitem><para>(This
      feature will be moved to an actual Operation in future releases and
      cleaned up).</para><para>mapper_list specifies a list of either builtin
      mappers or external mappers that map the names of Unknown types. An
      Unknown type is one that refers to a type which is not a declaration in
      the AST. For example, if you parse your C++ CORBA object but not the
      skeleton/stub .hh files, then any reference to a Fresco::POA_Graphic
      type object will be Unknown (since there is no Fresco::POA_Graphic in
      the AST). The builtin mapper &#34;C++toIDL&#34; transforms any unknown
      type name starting with POA_ to remove the POA_ and change the type to
      IDL, and any type name ending with _ptr to remove the _ptr and change
      the type to IDL. See the Mixed demo for an example of this in action.</para><para>The
      elements of the list may be a string, in which case it must be one of
      the builtin mappers (there is only one: C++toIDL currently), or it may
      be a 2-tuple of (&#34;module name or filename.py&#34;, &#34;object in
      module&#34;). The object in the module must have a &#34;map&#34;
      function or method that takes one argument: the Unknown type (see
      Synopsis.Core.Type.Unknown). The module name must be importable, which
      means it must be accessible from the PYTHON_PATH. A filename can be
      anywhere but must end in &#34;.py&#34;.</para><para>Can be set on the
      command line with, e.g.: &#34;-Wl,-m,module&#34; where module is either
      a module name or a filename.</para><para>...or with, e.g.:
      &#34;-Wl,-M,C++toIDL&#34; to specify a builtin module.</para></listitem></varlistentry><varlistentry><term>max_access
      (integer)</term><listitem><para>If set, removes any declaration that
      doesn&#39;t meet a level of visibility. This can be used to prune
      private or protected declarations from the AST so they wont be in the
      output. Values are:</para><para>1 : protected and private declarations
      removed</para><para>2 : private declarations removed</para><para>These
      actually follow the levels defined in Synopsis.Core.AST - levels higher
      than the given are removed (default is 0, public is 1, protected is 2,
      private is 3).</para></listitem></varlistentry><varlistentry><term>map_declaration_names
      (2-tuple or 2-list of name, type)</term><listitem><para>If set, causes
      all declarations to be mapped into a module of the given name and type.
      The name must be a scoped name, with &#34;::&#34; separating scopes. The
      type is the type of the modules used to extend the declarations into the
      given scope.</para><para>For example, the Synopsis RefManual uses this
      option to move all the C++ declarations into the Synopsis.Parser.C++
      python package with this option:</para><para>map_declaration_names =
      &#39;Synopsis::Parser::C++&#39;, &#39;Package&#39;</para><para>Package
      is used as the type since the Python AST has Packages for Synopsis,
      Parser and C++. (Note they are AST.Module objects, with type() set to
      &#34;Package&#34;).</para><para>All types referring to these
      declarations are renamed as appropriate.</para></listitem></varlistentry><varlistentry><term>comment_processors
      (list of strings)</term><listitem><para>If set, overrides the default
      setting of [&#39;summary&#39;]. Gives a list of comment processors to
      apply, in order, to the AST. See the Comments section above for a list
      of these and what they do.</para></listitem></varlistentry></variablelist></para>
    </section>
  </chapter>

  <chapter>
    <title>The HTML Formatter</title>

    <para>The HTML formatter is so comprehensive compared to the other
    formatters that it deserves a chapter of its own. See the next chapter for
    information about the other formatters available.</para>

    <section>
      <title>Basics</title>

      <para>Takes AST. Output directory. FileLayouts. Config object. Python,
      extensible</para>

      <para>The basic operation of the HTML formatter is that it takes an AST
      as input, and outputs a whole bunch of .html and .png files to an output
      directory. These files can either be all in the one directory or ordered
      into nested subdirectories (see the file_layout option). The output is
      created by individual modules called &#34;Pages&#34;, and like other
      parts of Synopsis you specify a list of these and they are executed in
      order. Each page generates a type of output, such as a frames index, the
      pages for classes and namespaces, an inheritance graph, the tree of
      modules to go in the corner frame, the index of individual modules to go
      in the left frame, etc.</para>

      <para>The order of pages is generally not important, but there are some
      effects: pages compete for index pages, such as which page gets to write
      the &#34;index.html&#34; page, which page gets to be the default page
      for the top-left frame, which page gets to be default for the left
      frame, etc. The Page which asks for one of these first, gets it, which
      is why FramesIndex usually comes first.</para>
    </section>

    <section>
      <title>Layouts</title>

      <para>The default layout is to have three frames:<variablelist><varlistentry><term>Top-left
      &#34;contents&#34; frame</term><listitem><para>This frame shows a tree
      heirarchy of the modules or files in the project. Clicking on a link
      opens that module or file in the &#34;index&#34; frame below.</para></listitem></varlistentry><varlistentry><term>Bottom-left
      &#34;index&#34; frame</term><listitem><para>This frame shows an index of
      the currently selected module or file, but only shows child classes,
      structs, namespaces or modules. When a module page is loaded in this
      frame and you have JavaScript enabled, a more detailed page will open in
      the main content area. For file pages you will need to click the
      &#34;File Details&#34; link.</para></listitem></varlistentry><varlistentry><term>Right
      &#34;main&#34; frame</term><listitem><para>This frame shows the main
      documentation. At the top of each page you can see a list of
      documentation areas you can visit: The Modules and Files open in the
      top-left frame, the Inheritance Graph/Tree and Name Index load in the
      main frame. For &#34;scope pages&#34; (i.e. the pages for classes and
      namespaces, including the global namespace which is the default page)
      the page is divided into summary and detail sections: the summary shows
      all the declarations in this class or namespace, with a summary for
      each. For declarations with more comments than just the summary, the
      name of the declaration will be highlighted, and clicking on it will
      take you to its detailed information further down the page.</para></listitem></varlistentry></variablelist></para>

      <para>This three-frame layout is inspired by JavaDoc, which is similar,
      but turns out to be less useful than it might be since most projects
      don&#39;t have a nice list of packages to go in the top-left frame like
      the Java libraries do. You will notice from the Synopsis RefManual
      however that an extensive Python project can fill the frame quite well.</para>

      <para>To enable the three-frame layout, the FramesIndex page must be
      included as the first Page. You should also have at least one of
      ModuleListing and FileListing, and ModuleIndexer and FileIndexer to fill
      in the frames.</para>

      <para>If you don&#39;t want frames then don&#39;t include the
      FramesIndex page. Whatever Page comes first will get to have the
      &#34;index.html&#34; page. For example, if ScopePages is first, then the
      index.html page will be the Global Namespace page. If DirBrowse is
      first, then it will be the listing of the project directory.</para>
    </section>

    <section>
      <title>Pages</title>

      <para>The output modules you can choose from are detailed below. Some
      generate multiple HTML files and others just one. Some use enough
      options that they have their own configuration sub-object, whereas
      others just use options in the main config object. Remember you can
      include or exclude any of these pages by setting the &#34;pages&#34;
      config option to a list of their names.</para>

      <para>Each page module extends from the Page base class, which provides
      both an interface to use and some default functionality (opening closing
      files, setting filenames and titles, etc). You can write your own Page
      class if one of the provided ones doesn&#39;t suit you, or extend from
      an existing one.</para>

      <section>
        <title>FramesIndex</title>

        <para>This page should always go first if you want frames, else it
        should not be included at all. There are no options to set.</para>
      </section>

      <section>
        <title>ScopePages</title>

        <para>This is the most complex output Page, creating the pages for
        each class and namespace/module/package. It walks the whole AST
        creating pages as it goes using flexible &#34;Parts&#34; and
        &#34;FormatStrategies&#34;.</para>

        <para>For each Scope in the AST, the output page has a number of
        Parts. You can write your own Parts, or change the order, but the
        usual four are &#39;Heading&#39;, &#39;Summary&#39;,
        &#39;Inheritance&#39; and &#39;Detail&#39;. A Part is responsible for
        visiting all the nodes in the Scope and formatting the sections for
        each type of declaration. It also provides methods for referencing
        other declarations with correct URLs, and things like formatting Types
        for display (with URLs for any names in the type). Each part has a
        list of FormatStrategies which it calls in turn for each declaration
        it processes, to generate the output HTML for that declaration.</para>

        <para>The difference between the four Parts is what declarations they
        process (pass to the formatters) on each page:<itemizedlist><listitem><para>The
        Heading part only processes the scope itself, and provides things like
        a page title, inheritance graph, and comments for the class or module.</para></listitem><listitem><para>The
        Summary part processes all the children of the scope, using a set of
        FormatStrategies to put them in a table with summary comments. Section
        headings are displayed for each type of declaration (methods,
        variables, etc).</para></listitem><listitem><para>The Inheritance part
        displays the methods inherited from base classes, taking care to hide
        overridden methods.</para></listitem><listitem><para>The Detail part
        processes all the children which have detailed information, using a
        set of FormatStrategies to list them sequentially with full comments
        and more detailed info (e.g.: for enums and long typedefs, exception
        specifications, etc).</para></listitem></itemizedlist></para>

        <para>You can control the output by changing the FormatStrategies used
        by each part, writing your own FormatStrategies, or even your own
        Parts!</para>

        <para>The FormatStrategies included with Synopsis are:<variablelist><varlistentry><term>Heading</term><listitem><para>Formats
        the heading of the page for the given declaration. For classes, it
        shows the class name, any template parameters, a link to the file the
        class was in, and the module/namespace name. The module/namespace name
        is placed in a DIV element with class &#34;class-namespace&#34; that
        by default is floated in the top-right corner of the page.</para></listitem></varlistentry><varlistentry><term>ClassHeirarchySimple</term><listitem><para>Displays
        the class hierarchy around this class in a textual manner. Mainly for
        use if you don&#39;t have/want graphviz (dot).</para></listitem></varlistentry><varlistentry><term>ClassHeirarchyGraph</term><listitem><para>Displays
        the class hierarchy around this class, including all parents, using
        the Dot formatter to create an embedded PNG image.</para></listitem></varlistentry><varlistentry><term>SummaryAST</term><listitem><para>Formats
        the elements of the AST in a Summary manner. That is, two columns,
        with the left column for the type and the right column for the name
        and other details. SummaryAST actually prints the column divider (a TD
        element). Declarations which will appear in the Detail section are
        linked to automatically where the name of the declaration is (so you
        click on the name and it takes you to the detail). For declarations
        with no detailed info, the name is not hyperlinked and the #name link
        will be to the summary.</para></listitem></varlistentry><varlistentry><term>DetailAST</term><listitem><para>Formats
        the elements of the AST in a Detailed manner. The declaration is
        printed out similar to how it would in code, and the comments and
        other details (e.g.: values for an enum) are shown expanded.</para></listitem></varlistentry><varlistentry><term>SummaryCommenter</term><listitem><para>Formats
        the comments of the declaration using a CommentFormatter instance, and
        puts them in a SPAN element of class &#39;summary&#39;, which in the
        default Synopsis CSS is italic.</para></listitem></varlistentry><varlistentry><term>DetailCommenter</term><listitem><para>Formats
        the comments of the declaration using a CommentFormatter instance, and
        puts them in a DIV element of class &#39;desc&#39;.</para></listitem></varlistentry><varlistentry><term>Inheritance</term><listitem><para>A
        simple formatter that just prints the name of the declaration with a
        link to its documentation, intended for use in the Inheritance Part.</para></listitem></varlistentry><varlistentry><term>SourceLinker</term><listitem><para>Formats
        a link to the source code for this declaration as &#34;[Source]&#34;.
        The source code is actually generated by the FileSource Page, so make
        sure you include that if you want to use this FormatStrategy, and vice
        versa.</para></listitem></varlistentry><varlistentry><term>XRefLinker</term><listitem><para>Formats
        a link to the cross-reference information for this declaration as
        &#34;[XRef]&#34;. The xref info is actually generated by the XRefPages
        Page, so make sure you include that if you want to use this
        FormatStrategy, and vice versa.</para></listitem></varlistentry></variablelist></para>

        <para>The default lists of strategies for each &#34;Part&#34; are:<variablelist><varlistentry><term>Heading</term><listitem><para>Heading,
        ClassHierarchyGraph, DetailCommenter</para></listitem></varlistentry><varlistentry><term>Summary</term><listitem><para>SummaryAST,
        SummaryCommenter</para></listitem></varlistentry><varlistentry><term>Inheritance</term><listitem><para>Inheritance</para></listitem></varlistentry><varlistentry><term>Detail</term><listitem><para>DetailAST,
        DetailCommenter</para></listitem></varlistentry></variablelist></para>

        <section>
          <title>ScopePages Options</title>

          <para>The ScopePages Page is the most complex to configure, since
          its layout is so flexible. Options are set in the sub-object
          &#34;ScopePages&#34; inside the HTML config object.</para>

          <para>The following options are available:<variablelist><varlistentry><term>parts</term><listitem><para>A
          list of Part objects to use on each page. Each list item is an
          import specification with the base package
          &#34;Synopsis.Formatter.HTML.ASTFormatter.&#34;, giving the
          following default parts:<programlisting>parts = [&#39;Heading&#39;, &#39;Summary&#39;, &#39;Inheritance&#39;, &#39;Detail&#39;]</programlisting></para></listitem></varlistentry><varlistentry><term>heading_formatters</term><listitem><para>A
          list of formatters to use in the Heading Part. Each list item is an
          import specification with the base package
          &#39;Synopsis.Formatter.HTML.FormatStrategy.&#39;, allowing you to
          specify any of the FormatStrategies listed earlier.</para><para>The
          default is:<programlisting>heading_formatters = [&#39;Heading&#39;, &#39;ClassHierarchyGraph&#39;, &#39;DetailCommenter&#39;]</programlisting></para></listitem></varlistentry><varlistentry><term>summary_formatters</term><listitem><para>A
          list of formatters to use in the Summary Part. Each list item is an
          import specification with the base package
          &#39;Synopsis.Formatter.HTML.FormatStrategy.&#39;, allowing you to
          specify any of the FormatStrategies listed earlier.</para><para>The
          default is:<programlisting>summary_formatters = [&#39;SummaryAST&#39;, &#39;SummaryCommenter&#39;]</programlisting></para></listitem></varlistentry><varlistentry><term>inheritance_formatters</term><listitem><para>A
          list of formatters to use in the Inheritance Part. Each list item is
          an import specification with the base package
          &#39;Synopsis.Formatter.HTML.FormatStrategy.&#39;, allowing you to
          specify any of the FormatStrategies listed earlier.</para><para>The
          default is:<programlisting>inheritance_formatters = [&#39;Inheritance&#39;]</programlisting></para></listitem></varlistentry><varlistentry><term>detail_formatters</term><listitem><para>A
          list of formatters to use in the Detail Part. Each list item is an
          import specification with the base package
          &#39;Synopsis.Formatter.HTML.FormatStrategy.&#39;, allowing you to
          specify any of the FormatStrategies listed earlier.</para><para>The
          default is:<programlisting>detail_formatters = [&#39;DetailAST&#39;, &#39;DetailCommenter&#39;]</programlisting></para></listitem></varlistentry></variablelist></para>
        </section>
      </section>

      <section>
        <title>ModuleListing</title>

        <para>This page creates a single output file with a tree of all
        packages/modules/namespaces in the AST. Each package/module/namespace
        is a link to an index file of that package, module or namespace.</para>

        <para>See the tree_formatter option for how to control the formatting
        of the tree.</para>

        <para>You can change the types of AST Module node which are included
        in this tree by creating a &#34;ModuleListing&#34; subobject and
        setting the option &#34;child_types&#34;. For example, the Python
        parser creates &#34;package&#34; and &#34;module&#34; types, IDL
        creates &#34;module&#34; types, and C++ creates &#34;namespaces&#34;.</para>

        <para>The ModuleListing Page creates a link at the top of all pages
        called &#34;Modules&#34; that is also shown in the top-left frame. You
        can change this text using the &#34;short_title&#34; option of the
        ModuleListing subobject.</para>

        <para>E.g.: To only show packages and change the title:<programlisting># Normal HTML config
class HTML (Base.Formatter.HTML):
    # A sub object for ModuleListing config
    class ModuleListing:
        child_types = [&#39;package&#39;] # only show packages
        short_title = &#39;Packages&#39;  # set the title to match</programlisting></para>

        <para>XXX There are two types of tree you can use: a simple HTML tree,
        or one that uses DHTML to open/close individual nodes, with little
        graphics for the buttons.</para>
      </section>

      <section>
        <title>ModuleIndexer</title>

        <para>This page goes hand in hand with ModuleListing, creating a
        concise listing of the declarations in each package/module/namespace.
        Each declaration is linked to its documentation, but clicking on
        another package/module/namespace will also load its index page in this
        frame if the user has javascript enabled. The declarations are sorted
        into types and displayed in their sections, just like in ScopePages.</para>
      </section>

      <section>
        <title>FileListing</title>

        <para>This page creates a single output file with a tree of all source
        files used to create the AST. Each file links to an index page of
        declarations in that file.</para>

        <para>See the tree_formatter option for how to control the formatting
        of the tree.</para>
      </section>

      <section>
        <title>FileIndexer</title>

        <para>Goes hand in hand with FileListing, creating the concise pages
        for each file.</para>

        <para>If you are using the FileSource Page, a [File Source] link will
        automatically be included at the top of the page.</para>

        <para>If you are using the FileDetails Page, a [File Details] link
        will automatically be included at the top of the page.</para>

        <para>Unlike ModuleIndexer, the declarations are displayed in the
        order they were in the file, with appropriate indenting for non-global
        declarations.</para>
      </section>

      <section>
        <title>FileDetails</title>

        <para>Shows details about each file, such as what files it included
        and a quick list of all the declarations declared in it.</para>
      </section>

      <section>
        <title>FileSource</title>

        <para>Shows source code for each file that the C++ parser created SXR
        info for. The actual markup of the source code is done by a C++ module
        for speed. The stored SXR info is used to hyperlink each identifier in
        the source code with a link to the documentation for that variable,
        class, etc, and also provide a hover text of what the identifier is,
        e.g: &#34;member variable LinkStore::private::buffer_start&#34; or
        &#34;local variable main&#34;. The ability to correctly identify the
        identifiers is dependent on the C++ parser, which is currently pretty
        good except for sometimes getting overloaded functions wrong, and not
        understanding template instantiations too well just yet.</para>
      </section>

      <section>
        <title>RawFilePages</title>

        <para>Shows source code for each file in the project as unformatted
        text.</para>
      </section>

      <section>
        <title>DirBrowse</title>

        <para>Shows directories in the project, where each file links to the
        source code from FileSource if available, the formatted page from
        RawFilePages if available, or is not a link if neither is available.</para>
      </section>

      <section>
        <title>XRefPages</title>

        <para>Creates pages with cross-reference information for each
        declaration. Each declaration will show its parent scope, child
        declarations if it&#39;s a class or module, references and places it
        was called from. You can navigate around the XRef documentation but
        there are no comments shown so it is more useful as an aside for
        either the source code or regular ScopePages documentation.</para>
      </section>

      <section>
        <title>InheritanceGraph</title>

        <para>Creates a single page with all inheritance graphs as embedded
        images using dot (graphviz) to create the graphs. Classes that have no
        subclasses or superclasses are not shown for brevity.</para>

        <para>XX options</para>
      </section>

      <section>
        <title>InheritanceTree</title>

        <para>Creates a single page with the entire object hierarchy in a tree
        structure. This page is a text-only alternative to the
        InheritanceGraph page, but both can be used without problems.</para>
      </section>

      <section>
        <title>NameIndex</title>

        <para>Creates a single page with an index of all class, variable,
        function/method and namespace/module names. The names are sorted
        alphabetically.</para>
      </section>
    </section>

    <section>
      <title>Options</title>

      <para>Other options than those mentioned above for specific pages are:</para>
    </section>
  </chapter>

  <chapter>
    <title>Other Formatters</title>

    <para>HTML</para>

    <para>HTML_Simple</para>

    <para>DocBook</para>

    <para>PDF</para>

    <para>Dia</para>

    <para>Dot</para>

    <para>ASCII</para>

    <para>DUMP (for debugging your config)</para>
  </chapter>

  <chapter>
    <title>Customising Synopsis</title>

    <para>formatter modules, load AST manually, etc.</para>
  </chapter>
</book>