<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.0/docbookx.dtd">
<book>
  <title>Synopsis User Manual</title>

  <chapter>
    <title>Introduction</title>

    <section>
      <title>What is Synopsis?</title>

      <para>Synopsis is a tool for creating documentation from source code,
      using both comments and the code itself - the code is actually parsed
      rather than just searching for comments and particular expressions.
      Currently Synopsis can parse C++, Python and CORBA IDL, and generate
      documentation in a range of formats including HTML, DocBook, PDF and Dia
      graphs.</para>

      <para>There are three stages in the documentation process: Parsing,
      Linking and Formatting. The data passed between each stage is an AST
      (Abstract Syntax Tree), a rich data structure which reflects the
      structure of the program. All three stages can be executed at once, or
      the AST can be stored to disk for later use.</para>

      <para>Parsing is performed by language-specific parser modules. The most
      advanced is the C++ parser which does correct name resolution and
      generates extra information used to syntax highlight the source code and
      cross-reference symbols.</para>

      <para>The Linking stage is where Synopsis derives most of its power,
      performing complex manipulations of the AST. At a minimum it handles the
      merging of multiple ASTs, eg: from different source files. It can
      manipulate the AST based on comments in the source, or perform things
      like renaming declarations to, for example, link directly to an IDL
      interface instead of a CORBA stub/skeleton.</para>

      <para>The Formatting stage generates the documentation from the AST
      output by the Linking stage. There are a number of modules, but the most
      common is the HTML module. The HTML formatter is very flexible, itself
      consisting of multiple &#34;Page&#34; modules each of which generates a
      part of the documentation (the index, the list of modules, the class
      documentation, the inheritance tree, etc.)</para>

      <para>Synopsis was written by Stephen Davies (aka Chalky) and Stefan
      Seefeld.</para>

      <para>This manual was written by Stephen Davies.</para>
    </section>

    <section>
      <title>How to use this manual</title>

      <para>Synopsis is very configurable, and this manual attempts to
      document all the features that can be enabled and how to configure them
      properly.</para>

      <para>The tutorial chapter shows some quick examples of how to get
      Synopsis working, and you can always check out the demos in the source
      distribution to see how some features work. Further chapters list all of
      the Parser, Linker and Formatter modules and all of the features/options
      available for each. Each feature has a detailed description, but for a
      quick reference you can also see the Config section of the Reference
      Manual generated from the Synopsis source code. You will also need the
      Reference Manual if you intend to write any extensions to Synopsis.</para>
    </section>

    <section>
      <title>How to use Synopsis</title>

      <para>Synopsis is a command-line tool, however a GUI may be included in
      future releases. Due to the highly configurable nature of Synopsis, it
      is not feasible to make a command line switch for each option. In order
      to aide testing and debugging of your configuration however, some of the
      more common options do have command line switches.</para>

      <para>So, the main way to configure Synopsis is with a config file,
      which is actually a Python script (usually config.py). This script is
      executed in a sandbox by Synopsis, and then its namespace is inspected
      to extract the configuration options. If you already know Python then
      you will have no problems reading and writing the script, and if you
      don&#39;t, well Python is really easy to learn - the Python tutorial
      included with Python will get you up to speed in half an hour or less!
      You don&#39;t need to know any of the builtin functions or libraries to
      write a config script.</para>

      <para>Synopsis uses three stages to generate documentation: parsing each
      source file to an AST (Abstract Syntax Tree), linking ASTs together and
      performing manipulations, and formatting the final AST. There are two
      ways to control this process:</para>

      <orderedlist>
        <listitem>
          <para>Use a Makefile, and run Synopsis multiple times. This allows
          you to integrate Synopsis with your existing build system. A simple
          Makefile has three rules: one to parse each source file to a .syn
          file, another to link all the .syn files into a single .syn file,
          and a third to format the final .syn file. All the configuration is
          stored in the config.py file and the only switches given to Synopsis
          are to indicate the stage of processing and the input/output
          filenames/directories.</para>
        </listitem>

        <listitem>
          <para>Use a Synopsis Project file. Project files are a new paradigm
          invented for the upcoming GUI which allows the entire process to
          execute with one synopsis command (eg: synopsis -P
          project.synopsis). It has some rules similar to make, with the
          exception that it does proper dependency checking and has flexible
          rules for selecting input files. The only downside is that in order
          to make the file easily readable and writable by the GUI it is much
          less readable and writable by hand.</para>
        </listitem>
      </orderedlist>

      <para>This manual will concentrate on the Makefile and config.py method,
      as this is the simplest to learn. All of the configuration options are
      valid in both files, with the exception of those for controlling the
      processing of the three stages in the second method.</para>

      <para>Synopsis can also integrate your project&#39;s documentation
      across multiple separate libraries or modules. An example is the best
      way to illustrate this: The Fresco Project has a Reference Manual for
      its IDL interfaces and its many implementation libraries and modules
      available online. Your project is a module which integrates with
      Fresco&#39;s display server, using both the IDL API and the display
      server&#39;s internal API. By downloading a .toc file (Table Of
      Contents) from the Fresco website, the documentation you generate for
      your project can link directly to Fresco&#39;s online documentation. For
      example, you have a method change_picture(Graphic g) where Graphic is an
      interface from the IDL API. In your documentation, Graphic will be a
      hyperlink to the documentation of the Graphic interface at the Fresco
      website. Neat huh? The Fresco documentation itself uses this feature to
      generate the documentation for each library separately, using .toc files
      to link to documentation of the libraries each library uses.</para>
    </section>

    <section>
      <title>Where to get more help</title>

      <para>Website: http://synopsis.sf.net</para>

      <para>Task/Bug/Patch/File manager at SourceForge:
      http://sourceforge.net/projects/synopsis/</para>

      <para>Mailing List: http://sourceforge.net/mail/?group_id=3169</para>

      <para>Reference Manual: Your distribution might have a -doc package for
      this, else it is in the docs/RefManual directory of the source
      distribution. This is a generated source code reference for Synopsis,
      but also included is complete documentation for the Configuration files
      (see the Config link in the top right of any page).</para>
    </section>
  </chapter>

  <chapter>
    <title>Tutorial</title>

    <section>
      <title>Running Synopsis</title>

      <para>Several demos are included with the source distribution, and are
      designed to be run without installing. However, if Synopsis is not
      installed then you will need to set your PYTHONPATH to include the
      Synopsis directory (the one with &#34;configure&#34;) and the
      &#34;share&#34; data (i.e.: icons) will not be accessible. There are
      demos for each parser, and some other feature demos, such as the Boost
      demo which documents Boost.Python and the Perceps demo which shows how
      to extend Synopsis to deal with &#34;strange&#34; commenting rules.</para>

      <para>Makefiles, stages, flags.</para>
    </section>

    <section>
      <title>The easy way: copy a demo config + modify</title>

      <para>The easiest way to get started using Synopsis is to copy a config
      file and maybe a Makefile from one of the demos.</para>

      <para>Let&#39;s say your project is called Player (it&#39;s a CD
      player!) has the following layout:</para>

      <programlisting>/src/Player/Makefile
/src/Player/src/player.cc     # main file
/src/Player/src/gui.cc        # GUI code
/src/Player/src/driver.cc     # CD playing code
/src/Player/include/driver.hh # Classes for the CD playing code
/src/Player/include/gui.hh    # Classes for the GUI code
/src/Player/syn/              # Intermediate Synopsis files will go here
/src/Player/doc/html/         # Synopsis documentation will go here</programlisting>

      <para>Since it is a C++ project, we will copy the simple-config.py from
      the C++ demo. The C++ demo has several examples it compiles, so the
      config.py file there is a bit more complex than we need.</para>

      <section>
        <title>The Makefile</title>

        <para>Your Makefile probably already has a variable FILES which lists
        the .cc files in src/, but Synopsis cares most about the header files.
        You will also need variables which contain the names of the .syn files
        generated by Synopsis&#39; parser, so add these lines to your
        Makefile:<programlisting># Project files
FILES = src/player.cc src/gui.cc src/driver.cc
INCLUDES = include/driver.hh include/gui.hh

# List of output .syn files for each input file
SYN_FILES = $(patsubst %,syn/%.syn,$(FILES) $(INCLUDES))</programlisting></para>

        <para>The patsubst line is a feature of (GNU) make that replaces a
        word (the %) with the word prefixed with syn/ (so the file goes in the
        syn directory) and suffixed with .syn (to mark it as a Synopsis file).
        This is done for both the source files and the include files.</para>

        <para>The first step is to add a rule which will compile your source
        files (including .hh files!) into Synopsis .syn files containing the
        parsed AST:<programlisting># A pattern rule to parse each input file
$(SYN_FILES): syn/%.syn: %
        # Here $@ is the output .syn file and $&#60; is the .cc or .hh file
        synopsis -c config.py -Wc,parser=C++ -o $@ $&#60;</programlisting></para>

        <para>The first line there is a pattern rule. It says that for each of
        the SYN_FILES, the output syn/%.syn depends on %. This means, for
        example, that syn/src/player.cc.syn depends on src/player.cc.</para>

        <para>The arguments to synopsis are:</para>

        <variablelist>
          <varlistentry>
            <term>-c config.py</term>

            <listitem>
              <para>Use the config file &#34;config.py&#34;. This is the
              Python script with the configuration options in it. We will get
              to this file later...</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-Wc,parser=C++</term>

            <listitem>
              <para>Gives the &#34;parser=C++&#34; option to the configuration
              module. Note that the -Wx,foo,bar style of command line option
              is borrowed from the GCC parser. Options are separated by commas
              and are passed to the relevant modules. Other modules you can
              address in this way are the parser
              (&#34;-Wp,-m,-s,myfile.cc.links&#34;), the linker
              (&#34;-Wl,-s,Foo::Bar&#34;) and the formatter
              (&#34;-Wf,-s,styleshee.css&#34;). In this case we are telling
              Synopsis to use the parser config with the name C++. This also
              tells it that the inputs are source files and must be parsed.
              See the config.py section below for more on this.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>-o $@</term>

            <listitem>
              <para>Output the AST to $@, which will be expanded by Make to be
              the output file, eg: syn/src/player.cc.syn</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>$&#60;</term>

            <listitem>
              <para>Input file, which will be expanded by Make to be the first
              dependancy - the source file, eg: src/player.cc</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Next is a rule to combine the multiple .syn files into a single
        one containing the whole AST for your project:<programlisting># The combined AST file which is the result of linking all files together
COMBINED = syn/combined.syn

# Make the combined file depend on all the intermediate files
$(COMBINED): $(SYN_FILES)
        # Link all the files together
        synopsis -c config.py -Wc,linker=Linker -o $(COMBINED) $(SYN_FILES)</programlisting></para>

        <para>The arguments to synopsis here are:</para>

        <variablelist>
          <varlistentry>
            <term>-Wc,linker=Linker</term>

            <listitem>
              <para>Similar to the previous -Wc option, this one tells
              Synopsis to use the linker config named as &#34;Linker&#34; in
              the config file. Since we didn&#39;t specify a parser, Synopsis
              assumes that the inputs are binary .syn files containing parsed
              ASTs.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>$(SYN_FILES)</term>

            <listitem>
              <para>A small note that make expands this variable to many files
              (5 in our example). Multiple AST files can be passed to the
              Linker, or to a formatter (in which case Synopsis links them
              with default options).</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Finally, a rule to format the combined AST into the HTML output.
        This step and the previous one can be done in one go, but this way you
        can generate multiple output formats from the one AST.<programlisting># The (main) final output file
HTML = doc/html/index.html

# Make the output file depend on the combined file
$(HTML): $(COMBINED)
        # Run synopsis to generate output
        synopsis -c config.py -Wc,formatter=HTML $(COMBINED)</programlisting></para>

        <para>The arguments should be obvious by now:</para>

        <variablelist>
          <varlistentry>
            <term>-Wc,formatter=HTML</term>

            <listitem>
              <para>Tells Synopsis to use the formatter config named
              &#34;HTML&#34;.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>Some housekeeping rules come last: A nice &#34;doc&#34; target
        so you can run &#34;make doc&#34;, and a clean target so you can run
        &#34;make clean&#34;. If you already have a clean target, just add
        this to your existing one.<programlisting># A doc target which creates the output file
doc:    $(HTML)

# A clean target which removes all the .syn files
clean:
        rm -rf $(COMBINED) $(SYN_FILES)</programlisting></para>

        <para>The final Makefile looks like this:<programlisting># Project files
FILES = src/player.cc src/gui.cc src/driver.cc
INCLUDES = include/driver.hh include/gui.hh

# List of output .syn files for each input file
SYN_FILES = $(patsubst %,syn/%.syn,$(FILES) $(INCLUDES))

# The (main) final output file
HTML = doc/html/index.html

# The combined AST file which is the result of linking all files together
COMBINED = syn/combined.syn

# A doc target which creates the output file
doc:    $(HTML)

# A clean target which removes all the .syn files
clean:
        rm -rf $(COMBINED) $(SYN_FILES)

# Make the output file depend on the combined file
$(HTML): $(COMBINED)
        # Run synopsis to generate output
        synopsis -c config.py -Wc,formatter=HTML $(COMBINED)

# Make the combined file depend on all the intermediate files
$(COMBINED): $(SYN_FILES)
        # Link all the files together
        synopsis -c config.py -Wc,linker=Linker -o $(COMBINED) $(SYN_FILES)

# A pattern rule to parse each input file
$(SYN_FILES): syn/%.syn: %
        # Here $@ is the output .syn file and $&#60; is the .cc or .hh file
        synopsis -c config.py -Wc,parser=C++ -o $@ $&#60;</programlisting></para>

        <para>You can find this Makefile in demo/Tutorial/Player.</para>
      </section>

      <section>
        <title>The config.py file</title>

        <para>Now that the Makefile is written it&#39;s time to look at the
        config file. The simple-config.py looks like this:<programlisting># Config file for C++ demos
# Only some files have comments in //. style
 
from Synopsis.Config import Base
 
class Config (Base):
    class Parser:
        class CXX (Base.Parser.CXX):
            main_file = 1
        modules = {
            &#39;C++&#39;:CXX,
        }
             
    class Linker:
        class LinkerJava (Base.Linker.Linker):
            comment_processors = [&#39;java&#39;, &#39;javatags&#39;, &#39;summary&#39;]
        modules = {
            &#39;Linker&#39;:LinkerJava,
        }
 
    class Formatter:
        class HTML (Base.Formatter.HTML):
            stylesheet_file = &#39;../html.css&#39;
 
        modules = Base.Formatter.modules
        modules[&#39;HTML&#39;] = HTML</programlisting></para>

        <para>It is important to remember that the config.py file is a real
        python script and is executed just like a Python program. This has the
        advantage of allowing familiar syntax and flexibility, but at the
        expense of a little security risk - however generating documentation
        for source code is probably less risky than running the source code
        itself, and a config.py file is easier to check.</para>

        <para>The first Python line is to access the &#34;default&#34; config
        options in the module Synopsis.Config. The default options are stored
        in the Base class, which has many subclasses for the different
        modules. You can see these in either the Config.py file itself, or in
        the generated reference manual. It is not strictly necessary to use
        the Base class, but it simplifies the config file somewhat by
        providing many sensible defaults.</para>

        <para>The rest of the file defines a class called Config, which has
        three subclasses called Parser, Linker and Formatter, representing the
        three stages of processing. Each of these subclasses contains a
        &#34;modules&#34; dictionary which lists different named
        configurations for that stage. Usually the only use for having
        different configurations is to use different modules (different
        parsers, different formatters), but you can also have multiple
        configurations for the same module. The most common example of this is
        to have multiple Linker configurations for different commenting styles
        and other options.</para>

        <para>Let&#39;s examine the file a section at a time:<programlisting>class Config (Base):</programlisting></para>

        <para>The Config class derives from the Base class (that we imported
        at the start of the file) which has a constructor to sort out the
        configurations in the config class. Remember that Python uses
        indentation to indicate scope, so the lines after this are all
        indented to indicate that they are part of the Config class.<programlisting>class Parser:</programlisting></para>

        <para>This is the first subclass, containing configurations for the
        Parser stage.<programlisting>class CXX (Base.Parser.CXX):
    main_file = 1</programlisting></para>

        <para>This is the only parser configuration in this config file.
        Configurations are classes too, but they are instantiated when they
        are used so they can have constructors to set options at run time.
        This configuration class is called &#34;CXX&#34; and derives from the
        class Base.Parser.CXX which has some default config options and also a
        constructor (so be sure to call it if you write your own).</para>

        <para>Configuration options are set as attributes in the config
        object, which the parser examines when it runs. The only one here sets
        the &#34;main_file&#34; option to &#34;1&#34;. See later chapters in
        this manual for more options, or the reference manual for a complete
        list.<programlisting>modules = {
    &#39;C++&#39;:CXX,
}</programlisting></para>

        <para>This little bit of code sets an attribute in the Parser class
        called modules, to a dictionary (note the braces aka curly brackets)
        of named configurations. Here &#39;C++&#39; is the name of the
        configuration to be used on the command line, and CXX (no quotes!)
        refers to the CXX class in the current scope. Note that the class was
        called CXX rather than C++ since C++ is not a valid class name.</para>

        <para>There is just one thing missing here: how does Synopsis actually
        know to use the C++ parser for this config? Surely it doesn&#39;t go
        by the name... The answer lies in the fact that we derived from the
        default configuration class Base.Parser.CXX. Looking in the Config.py
        file shows (amongst other things):<programlisting>class CXX:
    name = &#39;C++&#39;</programlisting></para>

        <para>Synopsis uses the name, along with the fact that the
        configuration was in the Parser section, to make the module name
        &#34;Synopsis.Parser.C++&#34;, load the module and look for a
        &#34;parse&#34; function. It turns out that C++ is a valid name for a
        package in Python, but only if you use the import() function (rather
        than an import statement). If you look in the site-packages directory
        (e.g. /usr/lib/python2.2/site-packages) you will see the file
        Synopsis/Parser/C++/__init__.py, which is the module actually loaded
        to get the C++ parser.</para>

        <para>To use a parser for a different language, the easiest thing to
        do is derive from one of Base.Parser.IDL or Base.Parser.Python, as
        appropriate. Note that the different parsers generally have different
        options.</para>

        <para>Getting back to the config file, the Linker section is pretty
        similar to the Parser section, except for this line:<programlisting>comment_processors = [&#39;java&#39;, &#39;javatags&#39;, &#39;summary&#39;]</programlisting></para>

        <para>The syntax here is setting the comment_processors attribute to a
        list of strings. The (square) brackets indicate a list (parentheses
        aka round brackets indicate a tuple, which is an immutable list).
        Strings can be either single or double quotes - Python makes no
        distinction between the two so it&#39;s just a matter of style.</para>

        <para>This particular option tells the Linker to apply the three
        comment processors called &#39;java&#39;, &#39;javatags&#39; and
        &#39;summary&#39; in that order. Comment processors are operations
        that use the comments attached to declarations to perform
        manipulations of either the comments or the AST itself:<variablelist><varlistentry><term>java</term><listitem><para>Looks
        for comments with the java commenting style of /** foo bar */. Any
        comments not matching this format are removed, and then the /** and */
        strings are also removed. Intermediate lines must begin with a *, so a
        multi-line comment looks like:<programlisting>/** The first sentence is a summary.
 * The rest of the comment goes here, with each line
 * beginning with a star. The closing star-slash can go
 * either by itself or at the end of a line.
 */</programlisting></para></listitem></varlistentry><varlistentry><term>javatags</term><listitem><para>Comments
        can have special &#34;tags&#34; which indicate either processing or
        formatting. This processor extracts the JavaDoc style tags from the
        comments and stores them with the comment for other processors or
        formatters to use. The tags must be at the end of the comment, but
        this allows them to span multiple lines if necessary. An example of
        JavaDoc tags is:<programlisting>/** Returns the height of the given person.
 * @param firstname the first name of the person
 * @param surname the surname of the person
 * @return the height of the person or 0 if the person was not found
 */
float getHeight(std::string firstname, std::string surname);</programlisting></para></listitem></varlistentry><varlistentry><term>summary</term><listitem><para>This
        processor extracts a summary of each comment and stores it with the
        comment, allowing the documentation to display a (usually one line)
        summary next to declarations in order to keep the pages tidy, and show
        the full comments elsewhere (e.g. further down the page). This
        processor also combines the comments for each declaration, so it
        should be the last one in the list.</para></listitem></varlistentry></variablelist></para>

        <para>See chapter XXX for a full list of comment processors.</para>

        <para>The HTML formatter we will have to change slightly. The
        stylesheet_file option tells the HTML formatter where to read the
        stylesheet from, and since the demo&#39;s are designed to run without
        Synopsis being installed, this is probably wrong. The default is to
        use the one installed in $prefix/share/Synopsis, so you can either
        delete the line or set it to the correct path. If you delete it,
        remember that Python needs the word &#34;pass&#34; for an empty class
        (or function):<programlisting>class HTML (Base.Formatter.HTML):
    pass</programlisting>Finally, the way the modules dictionary is set for
        the Formatter is a bit different. Here we first set it to the default
        value from the base class, then overwrite the entry for HTML with the
        new HTML formatter configuration. By using the default value like
        this, you get (default) configurations for all the different
        formatters.</para>
      </section>

      <section>
        <title>The output explained</title>

        <para>That&#39;s it! Just run &#34;make doc&#34; and hopefully it
        should all work. You will see Synopsis being run for each input file,
        to combine the ASTs, and the format the output.</para>

        <para>The HTML is output to whatever directory you set in the
        Makefile, which was written above as doc/html/. Point your web browser
        at the index.html file there to view the documentation, and you will
        see three frames (using the default configuration) similar to JavaDoc
        documentation:<variablelist><varlistentry><term>Top-left
        &#34;contents&#34; frame</term><listitem><para>This frame shows a tree
        heirarchy of the modules or files in the project. Clicking on a link
        opens that module or file in the &#34;index&#34; frame below.</para></listitem></varlistentry><varlistentry><term>Bottom-left
        &#34;index&#34; frame</term><listitem><para>This frame shows an index
        of the currently selected module or file, but only shows child
        classes, structs, namespaces or modules. When a module page is loaded
        in this frame and you have JavaScript enabled, a more detailed page
        will open in the main content area. For file pages you will need to
        click the &#34;File Details&#34; link.</para></listitem></varlistentry><varlistentry><term>Right
        &#34;main&#34; frame</term><listitem><para>This frame shows the main
        documentation. At the top of each page you can see a list of
        documentation areas you can visit: The Modules and Files open in the
        top-left frame, the Inheritance Graph/Tree and Name Index load in the
        main frame. For &#34;scope pages&#34; (i.e. the pages for classes and
        namespaces, including the global namespace which is the default page)
        the page is divided into summary and detail sections: the summary
        shows all the declarations in this class or namespace, with a summary
        for each. For declarations with more comments than just the summary,
        the name of the declaration will be highlighted, and clicking on it
        will take you to its detailed information further down the page.</para></listitem></varlistentry></variablelist></para>

        <para>You can also try out the other formatters. To see which
        formatters are available, run &#34;synopsis -l&#34;. To use a
        particular formatter, type:<programlisting>$ synopsis -c config.py -Wc,formatter=Dia -o player.dia syn/combined.syn</programlisting></para>

        <para>to use configuration from the config.py file (in our config file
        we just inherited the default options anyway), or you can just use the
        default options by typing:<programlisting>$ synopsis -f Dia -o player.dia syn/combined.syn</programlisting></para>

        <para>You can also pass command line options to the formatter with the
        following syntax:<programlisting>$ synopsis -f Dia -Wf,-p -o player.dia syn/combined.syn</programlisting></para>

        <para>This passes the -p option to the formatter. For the Dia
        formatter this tells it not to include parameters.</para>
      </section>
    </section>

    <section>
      <title>The hard way: create from scratch</title>

      <para>Allows flexibility. Mention deriving from Config.Base</para>
    </section>

    <section>
      <title>The powerful way: new config format</title>

      <para>Replace make. used by GUI. hard to read/write.</para>
    </section>

    <section>
      <title>The future way: use the GUI</title>

      <para>In some future release there will be a GUI to allow easy
      configuration of Synopsis.</para>

      <para></para>
    </section>
  </chapter>

  <chapter>
    <title>The Parsers</title>

    <section>
      <title>C++ Parser</title>

      <para>most advanced. SXR. XREF. UCPP, OCC</para>

      <para>The C++ parser reads C++ source code and generates an AST. It is
      the most advanced Synopsis parser, using the following components:<itemizedlist><listitem><para>A
      modified version of UCPP by Thomas Pornin. The modifications are to
      improve C++ standards conformance, and add features needed by Synopsis
      such as storing information about #includes and #defines, and recording
      the position of every macro expansion.</para></listitem><listitem><para>A
      modified version of OpenC++ (OCC) by Shigeru Chiba and others. OCC is
      used to generate a &#34;parse-tree&#34; from the preprocessed source
      code. The parse-tree is a data structure that directly represents the
      syntax of the source code. OCC uses Barry Boehm&#39;s garbage collector,
      but this can be disabled by passing --disable-gc to configure.</para></listitem><listitem><para>Code
      to &#34;walk&#34; the parse-tree and build an Abstract Syntax Tree. A
      symbol table is also maintained which is used to correctly resolve all
      types according to the C++ standard.</para></listitem><listitem><para>Code
      to record the positions of all macro expansions, keywords, comments,
      type and name references if SXR or XREF (see below) is enabled.</para></listitem><listitem><para>Miscellenous
      code to convert the C++ AST to a Python data structure, maintain the
      list of files, implement a Python module etc.</para></listitem></itemizedlist></para>

      <para>Like a compiler, the C++ parser has to parse the whole translation
      unit for each file to make sure it has the correct type references.
      Unfortunately this means it has to wade through all the standard library
      headers for each input file which, like with a compiler without
      precompiled headers, can take a long time. Luckily the C++ parser is
      written in C++ for speed and has been optimised in critical areas. If
      you are not using SXR or XREF then it skips all method bodies which
      speeds things up, and even if you are it only has to resolve type and
      function call information - there is no code generation or optimisation
      going on.</para>

      <para>Fortunately you can parse multiple headers in one go if you have a
      main header file which includes everything else (such as how
      python2.2/Python.h includes the other 41 Python header files), and if
      you are using a Project config file. See the multiple_files option
      below.</para>

      <section>
        <title>SXR and XREF</title>

        <para>So what are SXR and XREF?</para>

        <para>SXR stands for Synopsis Cross Reference. It is a combined
        feature of the C++ parser and the HTML formatter which displays the
        source code but with hyperlinks for every type reference and every
        name reference.</para>

        <para>This means that if you click on a method signature in the source
        code, you will be taken to the documentation. Each declaration in the
        documentation will also have a link to the source code. Variable and
        type references in the source code also have &#34;titles&#34;, which
        show as tooltips if you hover the mouse over them, telling you what
        they are (eg: &#34;parameter Person&#34; or &#34;member variable
        std::string&#34;). Note that because Synopsis uses a real C++ parser
        the links are always to the right declarations - unlike other systems
        which use purely string based references which are often ambiguous!</para>

        <para>XREF stands for Cross Reference. This feature creates an index
        of all references to every declaration, including function and method
        calls. This allows you to follow a call graph, or see where a method
        or class is used (useful for refactoring!)</para>

        <para>Both of these features need to be coordinated with both the C++
        parser and the HTML formatter.</para>

        <para>For SXR you need: C++ Parser: syntax_prefix, blah. HTML
        Formatter: The pages option must include &#39;FileSource&#39;.</para>

        <para>For XREF you need: C++ Parser: xref_prefix, blah. HTML
        Formatter: The pages option must include &#39;XRefPages&#39;.</para>

        <para>Note that in the current release there are some limitations with
        respect to expressions that are understood, and template
        instantiations are not supported very well. This means that in the
        source code some methods will not be hyperlinked and some cross
        references will be missing.</para>
      </section>

      <section>
        <title>Options</title>

        <para><variablelist><varlistentry><term>name (string)</term><listitem><para>Name
        of this config object: Must be &#39;C++&#39;</para></listitem></varlistentry><varlistentry><term>verbose
        (boolean)</term><listitem><para>Verbosity flag. For config files, this
        attribute is set by the constructor, but only if &#39;verbose&#39; was
        passed as a config option.</para><para>Can be set to true from the
        command line with &#34;-Wp,-v&#34;</para></listitem></varlistentry><varlistentry><term>main_file
        (boolean)</term><listitem><para>Flag that selects if should only store
        the AST generated from the file(s) being processed, and not included
        files. The default is 1 (true).</para><para>Can be set to true from
        the command line with &#34;-Wp,-m&#34;</para></listitem></varlistentry><varlistentry><term>basename
        (string)</term><listitem><para>A file path to strip from the start of
        all filenames before storing. Setting this option for example will
        remove any redundant parent directories in the HTML FileListing page.</para><para>Can
        be set from the command line with, e.g.:
        &#34;-Wp,-b,../some/basename/&#34;</para></listitem></varlistentry><varlistentry><term>include_path
        (list of strings)</term><listitem><para>A list of paths to add to the
        include path. For example: [&#39;/usr/local/corba/&#39;,
        &#39;../include&#39;]</para><para>Can be set from the command line
        with, e.g.: &#34;-Wp,-I,/usr/local/corba/,-I,../include&#34;</para></listitem></varlistentry><varlistentry><term>defines
        (list of strings)</term><listitem><para>A list of defines to pass to
        the preprocessor. For example: [&#39;FOO&#39;, &#39;BAR=true&#39;]</para><para>Can
        be set from the command line with, e.g.:
        &#34;-Wp,-D,FOO,-D,BAR=true&#34;</para></listitem></varlistentry><varlistentry><term>preprocessor
        (string)</term><listitem><para>Which preprocessor to use. Not setting
        this causes the builtin ucpp to be used, which can track macro
        expansions when doing SXR stuff and extract macro definitions for the
        documentation. Setting it to &#39;gcc&#39; will cause gcc (well,
        really g++) to be used instead, for use only in cases when ucpp
        can&#39;t parse your standard libraries (usually because of compiler
        specific syntax). There are no other settings.</para><para>Can be set
        to gcc from the command line with &#34;-Wp,-g&#34;</para></listitem></varlistentry><varlistentry><term>extract_tails
        (boolean)</term><listitem><para>If set to true, then the parser will
        look for trailing comments before close braces. If it finds them, it
        will create dummy declarations to hold the comments. If you set this,
        you should probably also use the &#39;dummy&#39; or &#39;prev&#39;
        comment processors in the Linker options otherwise you will see the
        Dummy declarations in your documentation.</para><para>Can be set to
        true from the command line with &#34;-Wp,-t&#34;</para></listitem></varlistentry><varlistentry><term>storage
        (string)</term><listitem><para>If set, this must be a string which
        defines the file to store links into. Setting this also causes the
        parser to look more carefully at the input file, so that it can
        generate the links from inside blocks of code (otherwise it skips over
        them). Note that you usually set this from the command-line with your
        Makefile via &#34;-Wp,-s,$@.links&#34; or something. (deprecated)</para></listitem></varlistentry><varlistentry><term>syntax_prefix
        (string)</term><listitem><para>If set, must be a string which defines
        a prefix to store syntax info into. The source filenames are appended
        to the prefix to create the output filename, so it should be a
        directory name to avoid clashes (there is no suffix!). For example, if
        your file is &#34;src/foo.cc&#34; and prefix is &#34;syn/&#34; then
        the syntax information will be stored in &#34;syn/src/foo.cc&#34;.</para></listitem></varlistentry><varlistentry><term>xref_prefix
        (string)</term><listitem><para>If set, must be a string which defines
        a prefix to store xref info into. See syntax_prefix.</para></listitem></varlistentry><varlistentry><term>syntax_file
        (string)</term><listitem><para>If set, must be a string with the file
        to store syntax info into. Note that the syntax info can only hold
        syntax information about one source file, so this option is of limited
        use in a config file.</para><para>Can be set from the command line
        with, e.g: &#34;-Wp,-s,syn/&#34;</para></listitem></varlistentry><varlistentry><term>xref_file
        (string)</term><listitem><para>If set, must be a string with the file
        to store xref info into. Note that the xref info can only hold xref
        information about one source file, so this option is of limited use in
        a config file.</para><para>Can be set from the command line with,
        e.g.: &#34;-Wp,-x,xref/&#34;</para></listitem></varlistentry><varlistentry><term>fake_std
        (boolean)</term><listitem><para>If set, this causes the parser to
        construct a fake using directive from the std namespace to the global
        namespace. In effect, this fixes problems seen with using the stdc++
        headers for gcc 2.95.x where most things dont get placed in the std
        namespace.</para><para>Can be set to true from the command line with
        &#34;-Wp,-f&#34;</para></listitem></varlistentry><varlistentry><term>multiple_files
        (boolean)</term><listitem><para>If set to true then the parser handles
        multiple files included from the main file at the same time. This
        option can only be used with the Project file. If syntax_prefix or
        xref_prefix is set then the extra files will get syntax and xref nfo
        recorded into the appropriate files. Only one AST is output, but it is
        as if the ASTs for the individual files were already linked.</para><para>To
        use this option, your Project file must have a single SourceAction
        connected to this ParserAction. The SourceAction should have a Simple
        rule first which is the main sourcefile, and any number of other rules
        to select other files to record the AST for.</para></listitem></varlistentry></variablelist></para>
      </section>
    </section>

    <section>
      <title>Python Parser</title>

      <para>The Python parser uses Python&#39;s parser library to create an
      AST from Python source code. This is adequate for the purposes of
      extracting classes, methods and their comments, but prevents the
      advanced features like syntax highlighting since the parse tree does not
      store line number information. There is no support for SXR or XREF
      features.</para>

      <section>
        <title>Options</title>

        <para></para>

        <variablelist>
          <varlistentry>
            <term>name (string)</term>

            <listitem>
              <para>Name of this config object: Must be &#39;Python&#39;</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>verbose (flag)</term>

            <listitem>
              <para>Verbosity flag. For config files, this attribute is set by
              the constructor, but only if &#39;verbose&#39; was passed as a
              config option.</para>

              <para>Can be set from the command line with &#34;-Wp,-v&#34;</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term>basename (string)</term>

            <listitem>
              <para>A file path to strip from the start of all filenames
              before storing. Setting this option for example will remove any
              redundant parent directories in the HTML FileListing page.</para>

              <para>Can be set from the command line with, e.g.:
              &#34;-Wp,-b,../some/basename/&#34;</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>

    <section>
      <title>CORBA IDL Parser</title>

      <para>The CORBA IDL Parser uses OmniORB&#39;s (Python) IDL compiler
      library to parse IDL files and generate an AST. You will need to have
      the omniidl package installed to use this parser. There is no support
      for SXR or XREF features.</para>

      <variablelist>
        <varlistentry>
          <term>name (string)</term>

          <listitem>
            <para>Name of this config object: Must be &#39;IDL&#39;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>verbose (boolean)</term>

          <listitem>
            <para>Verbosity flag. For config files, this attribute is set by
            the constructor, but only if &#39;verbose&#39; was passed as a
            config option.</para>

            <para>Can be set to true from the command line with
            &#34;-Wp,-v&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>main_file (boolean)</term>

          <listitem>
            <para>Flag that selects if should only store the AST generated
            from the file(s) being processed, and not included files. The
            default is 1 (true).</para>

            <para>Can be set to true from the command line with
            &#34;-Wp,-m&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>basename (string)</term>

          <listitem>
            <para>A file path to strip from the start of all filenames before
            storing. Setting this option for example will remove any redundant
            parent directories in the HTML FileListing page.</para>

            <para>Can be set from the command line with, e.g.:
            &#34;-Wp,-b,../some/basename/&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>include_path (list of strings)</term>

          <listitem>
            <para>A list of paths to add to the include path. For example:
            [&#39;/usr/local/corba/&#39;, &#39;../idl&#39;]</para>

            <para>Can be set from the command line with, e.g.:
            &#34;-Wp,-I,/usr/local/corba/,-I,../idl&#34;</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>keep_comments (boolean)</term>

          <listitem>
            <para>If true, comments will be stored in the AST. The default is
            true.</para>

            <para>Can be set to true from the command line with
            &#34;-Wp,-K&#34; (note upper case K)</para>

            <para>Can be set to false from the command line with
            &#34;-Wp,-k&#34;</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </chapter>

  <chapter>
    <title>The Linker</title>

    <para>only one.</para>

    <para>merge ASTs</para>

    <para>transformations based on comments</para>

    <para>moving/renaming AST subtrees</para>

    <para>mapping names (or how to link implementation to interface)</para>
  </chapter>

  <chapter>
    <title>The HTML Formatter</title>

    <para>The HTML formatter is so comprehensive compared to the other
    formatters that it deserves a chapter of its own.</para>

    <section>
      <title>Basics</title>

      <para>Takes AST. Output directory. FileLayouts. Config object. Python,
      extensible</para>
    </section>

    <section>
      <title>Layouts</title>

      <para>three panes, no frames, etc</para>
    </section>

    <section>
      <title>Pages</title>

      <para>Output generated by Pages, modules derived from the Page class.</para>

      <section>
        <title>ScopePages</title>

        <para></para>
      </section>

      <section>
        <title>ModuleListing</title>

        <para></para>
      </section>

      <section>
        <title>ModuleIndexer</title>

        <para></para>
      </section>

      <section>
        <title>FileListing</title>

        <para></para>
      </section>

      <section>
        <title>FileIndexer</title>

        <para></para>
      </section>

      <section>
        <title>FileDetails</title>

        <para></para>
      </section>

      <section>
        <title>FileSource</title>

        <para></para>
      </section>

      <section>
        <title>RawFilePages</title>

        <para></para>
      </section>

      <section>
        <title>XRefPages</title>

        <para></para>
      </section>

      <section>
        <title>InheritanceGraph</title>

        <para></para>
      </section>

      <section>
        <title>InheritanceTree</title>

        <para></para>
      </section>

      <section>
        <title>NameIndex</title>

        <para></para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Other Formatters</title>

    <para>HTML</para>

    <para>HTML_Simple</para>

    <para>DocBook</para>

    <para>PDF</para>

    <para>Dia</para>

    <para>Dot</para>

    <para>ASCII</para>

    <para>DUMP (for debugging your config)</para>
  </chapter>
</book>