#!/usr/bin/perl
'di';
'ig00';
#
##
# I have a Perl program called fixin that looks at the #! line, figures
# out the name of the interpreter, finds it on your path, then fixes
# that line.  Quite handy, and doesn't require exec'ing an extra
# /bin/sh.  Run the script itself through "nroff -man" for the man page.
#
# Revision 1.1  90/08/12  00:15:56  lwall
# Initial revision
# 

# fixin - fix interpreter lines on incoming scripts

$does_shbang = 1;		# Does kernel recognize #! hack?

$verbose = 1;			# Default to verbose

@absdirs = reverse grep(m!^/!, split(/:/, $ENV{'PATH'}, 999));

if ($ARGV[0] eq '-s') {
    shift;
    $verbose = 0;
}

die "Usage: fixin [-s] [files]\n" unless @ARGV || !-t;

@ARGV = '-' unless @ARGV;
FILE: foreach $filename (@ARGV) {
    open(IN, $filename) || ((warn "Can't open $filename\n"), next);
    $_ = <IN>;
    next FILE unless /^#!/;
    chop($cmd = $_);
    $cmd =~ s/^#! *//;
    ($cmd,$arg) = split(' ', $cmd, 2);
    $cmd =~ s!^.*/!!;
    $found = '';
    foreach $dir (@absdirs) {
	next if (-d "$dir/$cmd");
	if (-f "$dir/$cmd") {
	    warn "Ignoring $found\n" if $verbose && $found;
	    $found = "$dir/$cmd";
	}
    }
    if ($found) {
	warn "Changing $filename to $found\n" if $verbose;
	if ($does_shbang) {
	    $_ = "#!$found";
	    $_ .= ' ' . $arg if $arg ne '';
	    $_ .= "\n";
	}
	else {
	    $_ = <<EOF;
:
eval 'exec $found $arg -S \$0 \${1+"\$@"}'
    if \$running_under_some_shell;
EOF
	}
    }
    else {
	warn "Can't find $cmd in PATH, leaving $filename unchanged\n" if $verbose;
	next FILE;
    }
    if ($filename eq '-') {
	select(STDOUT);
    }
    else {
	rename($filename, "$filename.bak")
	    || ((warn "Can't modify $filename"), next FILE);
	open(OUT,">$filename") || die "Can't create new $filename: $!\n";
	($dev,$ino,$mode) = stat IN;
	$mode = 0644 unless $dev;
	chmod $mode, $filename;
	select(OUT);
    }
    print;
    while (<IN>) {
	print;
    }
    close IN;
    close OUT;
}
##############################################################################

	# These next few lines are legal in both Perl and nroff.

.00;			# finish .ig
 
'di			\" finish diversion--previous line must be blank
.nr nl 0-1		\" fake up transition to first page again
.nr % 0			\" start at page 1
'; __END__ ############# From here on it's a standard manual page ############
.TH FIXIN 1 "August 11, 1990"
.AT 3
.SH NAME
fixin \- fix incoming scripts to use reasonable #! line
.SH SYNOPSIS
.B fixin [-s] [files]
.SH DESCRIPTION
.I Fixin
fixes the specified files so that the #! line at the beginning of the
file reflects the actual location of the interpreter on this system.
The files are modified in place, with a .bak backup.
If no files are specified, acts as a filter.
It searches your current path for files matching the last component
of the current #! line and changes it to the first match.
.PP
The
.B \-s
switch makes fixin shutup about what it's doing.
.SH ENVIRONMENT
Uses absolute components of PATH to decide where to look for interpreters.
.SH FILES
None.
.SH AUTHOR
Larry Wall
.SH "SEE ALSO"
.SH DIAGNOSTICS
Warns you if there is more than one interpeter by that name in PATH.
.PP
Warns you if there is no interpreter by that name in PATH.
.SH BUGS
.ex
